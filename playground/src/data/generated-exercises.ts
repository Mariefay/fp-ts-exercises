// Auto-generated exercises from CLI version
// Generated on: 2026-02-07T19:00:10.759Z
// DO NOT EDIT MANUALLY - Run 'npm run generate:exercises' to regenerate

import { Exercise } from '@/types/exercise'

export const generatedExercises: Exercise[] = [
  {
    "id": "array-01",
    "title": "Map",
    "description": "Learn about map in fp-ts array",
    "category": "Array",
    "fileName": "01-map.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst doubleNumbers = (numbers: number[]): number[] => {\n  //TODO: Use Array.map to double each number in the array\n  //HINT: Import * as A from 'fp-ts/Array' and use pipe\n}\n\n// @ts-ignore\nconst extractNames = (users: Array<{ name: string; age: number }>): string[] => {\n  //TODO: Use Array.map to extract just the names from the user objects\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const doubleNumbers = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.map((n) => n * 2)\n  )\n\nexport const extractNames = (users: Array<{ name: string; age: number }>): string[] =>\n  pipe(\n    users,\n    A.map((user) => user.name)\n  )",
    "testCode": "describe('Array map operations', () => {\n  it('doubles all numbers in an array', () => {\n    const result = doubleNumbers([1, 2, 3, 4, 5])\n    expect(result).toEqual([2, 4, 6, 8, 10])\n  })\n\n  it('handles empty array', () => {\n    const result = doubleNumbers([])\n    expect(result).toEqual([])\n  })\n\n  it('extracts names from user objects', () => {\n    const users = [\n      { name: 'Alice', age: 25 },\n      { name: 'Bob', age: 30 },\n      { name: 'Charlie', age: 35 },\n    ]\n    const result = extractNames(users)\n    expect(result).toEqual(['Alice', 'Bob', 'Charlie'])\n  })\n})"
  },
  {
    "id": "array-02",
    "title": "Filter",
    "description": "Learn about filter in fp-ts array",
    "category": "Array",
    "fileName": "02-filter.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst filterEvenNumbers = (numbers: number[]): number[] => {\n  //TODO: Use Array.filter to keep only even numbers\n  //HINT: A number is even if n % 2 === 0\n}\n\n// @ts-ignore\nconst filterAdults = (users: Array<{ name: string; age: number }>): Array<{ name: string; age: number }> => {\n  //TODO: Use Array.filter to keep only users aged 18 or older\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const filterEvenNumbers = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.filter((n) => n % 2 === 0)\n  )\n\nexport const filterAdults = (users: Array<{ name: string; age: number }>): Array<{ name: string; age: number }> =>\n  pipe(\n    users,\n    A.filter((user) => user.age >= 18)\n  )",
    "testCode": "describe('Array filter operations', () => {\n  it('filters even numbers', () => {\n    const result = filterEvenNumbers([1, 2, 3, 4, 5, 6])\n    expect(result).toEqual([2, 4, 6])\n  })\n\n  it('returns empty array when no matches', () => {\n    const result = filterEvenNumbers([1, 3, 5])\n    expect(result).toEqual([])\n  })\n\n  it('filters adult users', () => {\n    const users = [\n      { name: 'Alice', age: 25 },\n      { name: 'Bob', age: 15 },\n      { name: 'Charlie', age: 30 },\n      { name: 'David', age: 17 },\n    ]\n    const result = filterAdults(users)\n    expect(result).toEqual([\n      { name: 'Alice', age: 25 },\n      { name: 'Charlie', age: 30 },\n    ])\n  })\n})"
  },
  {
    "id": "array-03",
    "title": "Reduce",
    "description": "Learn about reduce in fp-ts array",
    "category": "Array",
    "fileName": "03-reduce.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst sumNumbers = (numbers: number[]): number => {\n  //TODO: Use Array.reduce to sum all numbers\n  //HINT: Start with 0 as the initial value\n}\n\n// @ts-ignore\nconst concatenateStrings = (strings: string[]): string => {\n  //TODO: Use Array.reduce to concatenate all strings with a space between them\n  //HINT: Start with an empty string and trim the result\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const sumNumbers = (numbers: number[]): number =>\n  pipe(\n    numbers,\n    A.reduce(0, (acc, n) => acc + n)\n  )\n\nexport const concatenateStrings = (strings: string[]): string =>\n  pipe(\n    strings,\n    A.reduce('', (acc, str) => acc + ' ' + str),\n    (result) => result.trim()\n  )",
    "testCode": "describe('Array reduce operations', () => {\n  it('sums all numbers', () => {\n    const result = sumNumbers([1, 2, 3, 4, 5])\n    expect(result).toBe(15)\n  })\n\n  it('returns 0 for empty array', () => {\n    const result = sumNumbers([])\n    expect(result).toBe(0)\n  })\n\n  it('concatenates strings with spaces', () => {\n    const result = concatenateStrings(['Hello', 'functional', 'world'])\n    expect(result).toBe('Hello functional world')\n  })\n\n  it('handles single string', () => {\n    const result = concatenateStrings(['Hello'])\n    expect(result).toBe('Hello')\n  })\n})"
  },
  {
    "id": "array-04",
    "title": "Find",
    "description": "Learn about find in fp-ts array",
    "category": "Array",
    "fileName": "04-find.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst findFirstEven = (numbers: number[]): O.Option<number> => {\n  //TODO: Use Array.findFirst to find the first even number\n  //HINT: Returns an Option because the element might not exist\n}\n\n// @ts-ignore\nconst findUserByName = (users: Array<{ name: string; age: number }>, targetName: string): O.Option<{ name: string; age: number }> => {\n  //TODO: Use Array.findFirst to find a user by name\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const findFirstEven = (numbers: number[]): O.Option<number> =>\n  pipe(\n    numbers,\n    A.findFirst((n) => n % 2 === 0)\n  )\n\nexport const findUserByName = (users: Array<{ name: string; age: number }>, targetName: string): O.Option<{ name: string; age: number }> =>\n  pipe(\n    users,\n    A.findFirst((user) => user.name === targetName)\n  )",
    "testCode": "describe('Array find operations', () => {\n  it('finds first even number', () => {\n    const result = findFirstEven([1, 3, 4, 5, 6])\n    expect(O.isSome(result)).toBe(true)\n    expect(result).toEqual(O.some(4))\n  })\n\n  it('returns None when no even number found', () => {\n    const result = findFirstEven([1, 3, 5])\n    expect(O.isNone(result)).toBe(true)\n  })\n\n  it('finds user by name', () => {\n    const users = [\n      { name: 'Alice', age: 25 },\n      { name: 'Bob', age: 30 },\n      { name: 'Charlie', age: 35 },\n    ]\n    const result = findUserByName(users, 'Bob')\n    expect(result).toEqual(O.some({ name: 'Bob', age: 30 }))\n  })\n\n  it('returns None when user not found', () => {\n    const users = [{ name: 'Alice', age: 25 }]\n    const result = findUserByName(users, 'Bob')\n    expect(O.isNone(result)).toBe(true)\n  })\n})"
  },
  {
    "id": "array-05",
    "title": "Partition",
    "description": "Learn about partition in fp-ts array",
    "category": "Array",
    "fileName": "05-partition.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ntype Partitioned<T> = {\n  readonly left: T[]\n  readonly right: T[]\n}\n\n// @ts-ignore\nconst partitionByAge = (users: Array<{ name: string; age: number }>): Partitioned<{ name: string; age: number }> => {\n  //TODO: Use Array.partition to separate adults (18+) from minors\n  //HINT: partition returns { left: failing predicate, right: passing predicate }\n}\n\n// @ts-ignore\nconst partitionNumbers = (numbers: number[]): Partitioned<number> => {\n  //TODO: Use Array.partition to separate odd and even numbers\n  //HINT: right array will contain elements passing the predicate (even numbers)\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Partitioned<T> = {\n  readonly left: T[]\n  readonly right: T[]\n}\n\nexport const partitionByAge = (users: Array<{ name: string; age: number }>): Partitioned<{ name: string; age: number }> =>\n  pipe(\n    users,\n    A.partition((user) => user.age >= 18)\n  )\n\nexport const partitionNumbers = (numbers: number[]): Partitioned<number> =>\n  pipe(\n    numbers,\n    A.partition((n) => n % 2 === 0)\n  )",
    "testCode": "describe('Array partition operations', () => {\n  it('partitions users by age', () => {\n    const users = [\n      { name: 'Alice', age: 25 },\n      { name: 'Bob', age: 15 },\n      { name: 'Charlie', age: 30 },\n      { name: 'David', age: 17 },\n    ]\n    const result = partitionByAge(users)\n    expect(result.left).toEqual([\n      { name: 'Bob', age: 15 },\n      { name: 'David', age: 17 },\n    ])\n    expect(result.right).toEqual([\n      { name: 'Alice', age: 25 },\n      { name: 'Charlie', age: 30 },\n    ])\n  })\n\n  it('partitions numbers into odd and even', () => {\n    const result = partitionNumbers([1, 2, 3, 4, 5, 6])\n    expect(result.left).toEqual([1, 3, 5])\n    expect(result.right).toEqual([2, 4, 6])\n  })\n})"
  },
  {
    "id": "array-06",
    "title": "Sort",
    "description": "Learn about sort in fp-ts array",
    "category": "Array",
    "fileName": "06-sort.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst sortNumbersAscending = (numbers: number[]): number[] => {\n  //TODO: Use Array.sort with Ord.fromCompare to sort numbers in ascending order\n  //HINT: Use N.Ord for number ordering\n}\n\n// @ts-ignore\nconst sortUsersByAge = (users: Array<{ name: string; age: number }>): Array<{ name: string; age: number }> => {\n  //TODO: Use Array.sort with a custom Ord to sort users by age\n  //HINT: Use Ord.contramap to create an Ord for user objects based on age\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const sortNumbersAscending = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.sort(N.Ord)\n  )\n\nconst userByAge = pipe(\n  N.Ord,\n  Ord.contramap((user: { name: string; age: number }) => user.age)\n)\n\nexport const sortUsersByAge = (users: Array<{ name: string; age: number }>): Array<{ name: string; age: number }> =>\n  pipe(\n    users,\n    A.sort(userByAge)\n  )",
    "testCode": "describe('Array sort operations', () => {\n  it('sorts numbers in ascending order', () => {\n    const result = sortNumbersAscending([5, 2, 8, 1, 9])\n    expect(result).toEqual([1, 2, 5, 8, 9])\n  })\n\n  it('handles empty array', () => {\n    const result = sortNumbersAscending([])\n    expect(result).toEqual([])\n  })\n\n  it('sorts users by age', () => {\n    const users = [\n      { name: 'Alice', age: 30 },\n      { name: 'Bob', age: 25 },\n      { name: 'Charlie', age: 35 },\n    ]\n    const result = sortUsersByAge(users)\n    expect(result).toEqual([\n      { name: 'Bob', age: 25 },\n      { name: 'Alice', age: 30 },\n      { name: 'Charlie', age: 35 },\n    ])\n  })\n})"
  },
  {
    "id": "array-07",
    "title": "Chaining",
    "description": "Learn about chaining in fp-ts array",
    "category": "Array",
    "fileName": "07-chaining.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getAdultNames = (users: Array<{ name: string; age: number }>): string[] => {\n  //TODO: Chain Array.filter and Array.map to get names of users 18 or older\n  //HINT: First filter for adults, then map to get just the names\n}\n\n// @ts-ignore\nconst doubleEvenNumbers = (numbers: number[]): number[] => {\n  //TODO: Chain Array.filter and Array.map to double only the even numbers\n  //HINT: Filter for even numbers, then map to double them\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const getAdultNames = (users: Array<{ name: string; age: number }>): string[] =>\n  pipe(\n    users,\n    A.filter((user) => user.age >= 18),\n    A.map((user) => user.name)\n  )\n\nexport const doubleEvenNumbers = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.filter((n) => n % 2 === 0),\n    A.map((n) => n * 2)\n  )",
    "testCode": "describe('Array chaining operations', () => {\n  it('gets names of adult users', () => {\n    const users = [\n      { name: 'Alice', age: 25 },\n      { name: 'Bob', age: 15 },\n      { name: 'Charlie', age: 30 },\n      { name: 'David', age: 17 },\n    ]\n    const result = getAdultNames(users)\n    expect(result).toEqual(['Alice', 'Charlie'])\n  })\n\n  it('doubles only even numbers', () => {\n    const result = doubleEvenNumbers([1, 2, 3, 4, 5, 6])\n    expect(result).toEqual([4, 8, 12])\n  })\n\n  it('handles empty array', () => {\n    const result = getAdultNames([])\n    expect(result).toEqual([])\n  })\n})"
  },
  {
    "id": "array-08",
    "title": "Flatmap",
    "description": "Learn about flatmap in fp-ts array",
    "category": "Array",
    "fileName": "08-flatmap.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ntype User = {\n  name: string\n  hobbies: string[]\n}\n\n// @ts-ignore\nconst getAllHobbies = (users: User[]): string[] => {\n  //TODO: Use Array.flatMap (or chain + flatten) to get all hobbies from all users\n  //HINT: flatMap is like map followed by flatten - it extracts and flattens in one step\n}\n\n// @ts-ignore\nconst explodeNumbers = (numbers: number[]): number[] => {\n  //TODO: Use Array.flatMap to create an array where each number appears twice\n  //HINT: For each number n, return [n, n]\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype User = {\n  name: string\n  hobbies: string[]\n}\n\nexport const getAllHobbies = (users: User[]): string[] =>\n  pipe(\n    users,\n    A.flatMap((user) => user.hobbies)\n  )\n\nexport const explodeNumbers = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.flatMap((n) => [n, n])\n  )",
    "testCode": "describe('Array flatMap operations', () => {\n  it('gets all hobbies from all users', () => {\n    const users: User[] = [\n      { name: 'Alice', hobbies: ['reading', 'gaming'] },\n      { name: 'Bob', hobbies: ['cooking'] },\n      { name: 'Charlie', hobbies: ['running', 'cycling', 'swimming'] },\n    ]\n    const result = getAllHobbies(users)\n    expect(result).toEqual(['reading', 'gaming', 'cooking', 'running', 'cycling', 'swimming'])\n  })\n\n  it('explodes numbers into pairs', () => {\n    const result = explodeNumbers([1, 2, 3])\n    expect(result).toEqual([1, 1, 2, 2, 3, 3])\n  })\n\n  it('handles empty array', () => {\n    const result = getAllHobbies([])\n    expect(result).toEqual([])\n  })\n})"
  },
  {
    "id": "array-09",
    "title": "Compact",
    "description": "Learn about compact in fp-ts array",
    "category": "Array",
    "fileName": "09-compact.exercise.ts",
    "difficulty": "advanced",
    "order": 9,
    "exerciseCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getValidNumbers = (numbers: Array<O.Option<number>>): number[] => {\n  //TODO: Use Array.compact to remove all None values and extract Some values\n  //HINT: compact removes None and unwraps Some values\n}\n\n// @ts-ignore\nconst safeDivide = (numbers: number[]): number[] => {\n  //TODO: Divide 100 by each number, but safely handle division by zero\n  //HINT: First map to Option (Some for valid, None for zero), then compact\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const getValidNumbers = (numbers: Array<O.Option<number>>): number[] =>\n  pipe(\n    numbers,\n    A.compact\n  )\n\nexport const safeDivide = (numbers: number[]): number[] =>\n  pipe(\n    numbers,\n    A.map((n) => (n === 0 ? O.none : O.some(100 / n))),\n    A.compact\n  )",
    "testCode": "describe('Array compact operations', () => {\n  it('removes None values and extracts Some values', () => {\n    const numbers = [O.some(1), O.none, O.some(2), O.none, O.some(3)]\n    const result = getValidNumbers(numbers)\n    expect(result).toEqual([1, 2, 3])\n  })\n\n  it('returns empty array when all None', () => {\n    const numbers = [O.none, O.none, O.none]\n    const result = getValidNumbers(numbers)\n    expect(result).toEqual([])\n  })\n\n  it('safely divides numbers, skipping zeros', () => {\n    const result = safeDivide([2, 0, 5, 0, 10])\n    expect(result).toEqual([50, 20, 10])\n  })\n})"
  },
  {
    "id": "array-10",
    "title": "Pipeline",
    "description": "Learn about pipeline in fp-ts array",
    "category": "Array",
    "fileName": "10-pipeline.exercise.ts",
    "difficulty": "advanced",
    "order": 10,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ntype Product = {\n  id: number\n  name: string\n  price: number\n  category: string\n  inStock: boolean\n}\n\n// @ts-ignore\nconst getAffordableElectronics = (products: Product[], maxPrice: number): string[] => {\n  //TODO: Create a pipeline that:\n  // 1. Filters for electronics category\n  // 2. Filters for in-stock items\n  // 3. Filters for items under maxPrice\n  // 4. Sorts by price (lowest first)\n  // 5. Maps to product names\n}\n\n// @ts-ignore\nconst calculateTotalRevenue = (orders: Array<{ items: Array<{ price: number; quantity: number }> }>): number => {\n  //TODO: Create a pipeline that:\n  // 1. FlatMaps to get all items from all orders\n  // 2. Maps each item to its total (price * quantity)\n  // 3. Reduces to sum all totals\n}",
    "solutionCode": "import * as A from 'fp-ts/Array'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Product = {\n  id: number\n  name: string\n  price: number\n  category: string\n  inStock: boolean\n}\n\nexport const getAffordableElectronics = (products: Product[], maxPrice: number): string[] =>\n  pipe(\n    products,\n    A.filter((p) => p.category === 'Electronics'),\n    A.filter((p) => p.inStock),\n    A.filter((p) => p.price <= maxPrice),\n    A.sort(pipe(N.Ord, (ord) => ({ compare: (a: Product, b: Product) => ord.compare(a.price, b.price) }))),\n    A.map((p) => p.name)\n  )\n\nexport const calculateTotalRevenue = (orders: Array<{ items: Array<{ price: number; quantity: number }> }>): number =>\n  pipe(\n    orders,\n    A.flatMap((order) => order.items),\n    A.map((item) => item.price * item.quantity),\n    A.reduce(0, (acc, total) => acc + total)\n  )",
    "testCode": "describe('Array real-world pipeline', () => {\n  it('gets affordable electronics sorted by price', () => {\n    const products: Product[] = [\n      { id: 1, name: 'Laptop', price: 999, category: 'Electronics', inStock: true },\n      { id: 2, name: 'Mouse', price: 25, category: 'Electronics', inStock: true },\n      { id: 3, name: 'Desk', price: 300, category: 'Furniture', inStock: true },\n      { id: 4, name: 'Keyboard', price: 75, category: 'Electronics', inStock: true },\n      { id: 5, name: 'Monitor', price: 400, category: 'Electronics', inStock: false },\n      { id: 6, name: 'Headphones', price: 150, category: 'Electronics', inStock: true },\n    ]\n    const result = getAffordableElectronics(products, 200)\n    expect(result).toEqual(['Mouse', 'Keyboard', 'Headphones'])\n  })\n\n  it('calculates total revenue from multiple orders', () => {\n    const orders = [\n      { items: [{ price: 10, quantity: 2 }, { price: 5, quantity: 3 }] },\n      { items: [{ price: 20, quantity: 1 }] },\n      { items: [{ price: 15, quantity: 2 }, { price: 8, quantity: 4 }] },\n    ]\n    const result = calculateTotalRevenue(orders)\n    // (10*2 + 5*3) + (20*1) + (15*2 + 8*4) = (20 + 15) + 20 + (30 + 32) = 35 + 20 + 62 = 117\n    expect(result).toBe(117)\n  })\n})"
  },
  {
    "id": "either-01",
    "title": "Left And Right",
    "description": "Learn about left and right in fp-ts either",
    "category": "Either",
    "fileName": "01-left-and-right.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserById = (id: number, users: User[]): E.Either<UserError, User> => {\n  //TODO:\n  //Check if the ID is valid (greater than 0)\n  //If invalid, return E.left with 'Invalid ID' error\n  //Try to find the user in the users array\n  //If found, return E.right with the user\n  //If not found, return E.left with 'User not found' error\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserById = (id: number, users: User[]): E.Either<UserError, User> => {\n  if (id <= 0) {\n    return E.left('Invalid ID')\n  }\n\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}",
    "testCode": "describe('getUserById', () => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' },\n  ]\n\n  it('returns left with error for invalid ID', () => {\n    const result = getUserById(0, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns right with user if found', () => {\n    const result = getUserById(2, users)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 2, name: 'Bob' } })\n  })\n\n  it('returns left with error if user not found', () => {\n    const result = getUserById(99, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "either-02",
    "title": "Map",
    "description": "Learn about map in fp-ts either",
    "category": "Either",
    "fileName": "02-map.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserError = 'User not found'\n\n// @ts-ignore\nconst getUserEmail = (userEither: E.Either<UserError, User>): E.Either<UserError, string> => {\n  //TODO:\n  //Use E.map to extract the email from the user\n  //If userEither is Right, map the user to their email\n  //If userEither is Left, the error passes through unchanged\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserError = 'User not found'\n\nexport const getUserEmail = (userEither: E.Either<UserError, User>): E.Either<UserError, string> =>\n  pipe(\n    userEither,\n    E.map(user => user.email)\n  )",
    "testCode": "describe('getUserEmail', () => {\n  const user: User = { id: 1, name: 'Alice', email: 'alice@example.com' }\n  const userRight: E.Either<UserError, User> = E.right(user)\n  const userLeft: E.Either<UserError, User> = E.left('User not found')\n\n  it('maps right value to email', () => {\n    const result = getUserEmail(userRight)\n    expect(result).toEqual({ _tag: 'Right', right: 'alice@example.com' })\n  })\n\n  it('preserves left value', () => {\n    const result = getUserEmail(userLeft)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "either-03",
    "title": "Fold",
    "description": "Learn about fold in fp-ts either",
    "category": "Either",
    "fileName": "03-fold.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserName = (userEither: E.Either<UserError, User>): string => {\n  //TODO:\n  //Use E.fold to handle both Left and Right cases\n  //If Left, return the error message as a string\n  //If Right, return the user's name\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserName = (userEither: E.Either<UserError, User>): string =>\n  pipe(\n    userEither,\n    E.fold(\n      (error) => error,\n      (user) => user.name\n    )\n  )",
    "testCode": "describe('getUserName', () => {\n  const userRight: E.Either<UserError, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft1: E.Either<UserError, User> = E.left('Invalid ID')\n  const userLeft2: E.Either<UserError, User> = E.left('User not found')\n\n  it('returns user name for right value', () => {\n    const result = getUserName(userRight)\n    expect(result).toEqual('Alice')\n  })\n\n  it('returns error message for left value - Invalid ID', () => {\n    const result = getUserName(userLeft1)\n    expect(result).toEqual('Invalid ID')\n  })\n\n  it('returns error message for left value - User not found', () => {\n    const result = getUserName(userLeft2)\n    expect(result).toEqual('User not found')\n  })\n})"
  },
  {
    "id": "either-04",
    "title": "Chain",
    "description": "Learn about chain in fp-ts either",
    "category": "Either",
    "fileName": "04-chain.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\ntype ValidationError = 'Invalid ID' | 'User not found' | 'User too young'\n\nconst findUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  if (id <= 0) return E.left('Invalid ID')\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}\n\n// @ts-ignore\nconst validateAge = (user: User): E.Either<ValidationError, User> => {\n  //TODO:\n  //Check if user.age is >= 18\n  //If yes, return E.right(user)\n  //If no, return E.left('User too young')\n}\n\n// @ts-ignore\nconst findAndValidateUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  //TODO:\n  //Use E.chain to compose findUser and validateAge\n  //First find the user, then validate their age\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\ntype ValidationError = 'Invalid ID' | 'User not found' | 'User too young'\n\nconst findUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  if (id <= 0) return E.left('Invalid ID')\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}\n\nexport const validateAge = (user: User): E.Either<ValidationError, User> => {\n  return user.age >= 18 ? E.right(user) : E.left('User too young')\n}\n\nexport const findAndValidateUser = (id: number, users: User[]): E.Either<ValidationError, User> =>\n  pipe(\n    findUser(id, users),\n    E.chain(validateAge)\n  )",
    "testCode": "describe('findAndValidateUser', () => {\n  const users = [\n    { id: 1, name: 'Alice', age: 25 },\n    { id: 2, name: 'Bob', age: 16 },\n    { id: 3, name: 'Charlie', age: 30 },\n  ]\n\n  it('returns right with user if valid and adult', () => {\n    const result = findAndValidateUser(1, users)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice', age: 25 } })\n  })\n\n  it('returns left if ID is invalid', () => {\n    const result = findAndValidateUser(0, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns left if user not found', () => {\n    const result = findAndValidateUser(99, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n\n  it('returns left if user too young', () => {\n    const result = findAndValidateUser(2, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User too young' })\n  })\n})"
  },
  {
    "id": "either-05",
    "title": "From Predicate",
    "description": "Learn about from predicate in fp-ts either",
    "category": "Either",
    "fileName": "05-from-predicate.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\n// @ts-ignore\nconst validateAdult = (user: User): E.Either<string, User> => {\n  //TODO:\n  //Use E.fromPredicate to validate that user.age >= 18\n  //If true, return E.right(user)\n  //If false, return E.left('Must be 18 or older')\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nexport const validateAdult = (user: User): E.Either<string, User> =>\n  pipe(\n    user,\n    E.fromPredicate(\n      (u) => u.age >= 18,\n      () => 'Must be 18 or older'\n    )\n  )",
    "testCode": "describe('validateAdult', () => {\n  const adult: User = { id: 1, name: 'Alice', age: 25 }\n  const minor: User = { id: 2, name: 'Bob', age: 16 }\n\n  it('returns right for adult user', () => {\n    const result = validateAdult(adult)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice', age: 25 } })\n  })\n\n  it('returns left for minor user', () => {\n    const result = validateAdult(minor)\n    expect(result).toEqual({ _tag: 'Left', left: 'Must be 18 or older' })\n  })\n})"
  },
  {
    "id": "either-06",
    "title": "Error Handling",
    "description": "Learn about error handling in fp-ts either",
    "category": "Either",
    "fileName": "06-error-handling.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  stock: number\n}\n\ntype PurchaseError =\n  | 'Product not found'\n  | 'Out of stock'\n  | 'Insufficient funds'\n\ninterface Purchase {\n  product: Product\n  remainingBalance: number\n}\n\n// @ts-ignore\nconst purchaseProduct = (\n  productId: number,\n  balance: number,\n  products: Product[]\n): E.Either<PurchaseError, Purchase> => {\n  //TODO:\n  //1. Find the product by ID, return E.left('Product not found') if not found\n  //2. Check if product.stock > 0, return E.left('Out of stock') if not\n  //3. Check if balance >= product.price, return E.left('Insufficient funds') if not\n  //4. Return E.right with { product, remainingBalance: balance - product.price }\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  stock: number\n}\n\ntype PurchaseError =\n  | 'Product not found'\n  | 'Out of stock'\n  | 'Insufficient funds'\n\ninterface Purchase {\n  product: Product\n  remainingBalance: number\n}\n\nexport const purchaseProduct = (\n  productId: number,\n  balance: number,\n  products: Product[]\n): E.Either<PurchaseError, Purchase> => {\n  const product = products.find(p => p.id === productId)\n\n  if (!product) {\n    return E.left('Product not found')\n  }\n\n  if (product.stock === 0) {\n    return E.left('Out of stock')\n  }\n\n  if (balance < product.price) {\n    return E.left('Insufficient funds')\n  }\n\n  return E.right({\n    product,\n    remainingBalance: balance - product.price\n  })\n}",
    "testCode": "describe('purchaseProduct', () => {\n  const products = [\n    { id: 1, name: 'Laptop', price: 1000, stock: 5 },\n    { id: 2, name: 'Mouse', price: 25, stock: 0 },\n    { id: 3, name: 'Keyboard', price: 75, stock: 10 },\n  ]\n\n  it('successfully purchases product', () => {\n    const result = purchaseProduct(1, 1500, products)\n    expect(result).toEqual({\n      _tag: 'Right',\n      right: { product: products[0], remainingBalance: 500 }\n    })\n  })\n\n  it('returns error for non-existent product', () => {\n    const result = purchaseProduct(99, 1000, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Product not found' })\n  })\n\n  it('returns error for out of stock product', () => {\n    const result = purchaseProduct(2, 1000, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Out of stock' })\n  })\n\n  it('returns error for insufficient funds', () => {\n    const result = purchaseProduct(1, 500, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Insufficient funds' })\n  })\n})"
  },
  {
    "id": "either-07",
    "title": "Get Or Else",
    "description": "Learn about get or else in fp-ts either",
    "category": "Either",
    "fileName": "07-get-or-else.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'User not found'\n\n// @ts-ignore\nconst getUserName = (userEither: E.Either<UserError, User>): string => {\n  //TODO:\n  //Use E.getOrElse to extract the user's name\n  //If Right, return the user's name\n  //If Left, return 'Anonymous'\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'User not found'\n\nexport const getUserName = (userEither: E.Either<UserError, User>): string =>\n  pipe(\n    userEither,\n    E.map(user => user.name),\n    E.getOrElse(() => 'Anonymous')\n  )",
    "testCode": "describe('getUserName', () => {\n  const userRight: E.Either<UserError, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft: E.Either<UserError, User> = E.left('User not found')\n\n  it('returns user name for right value', () => {\n    const result = getUserName(userRight)\n    expect(result).toEqual('Alice')\n  })\n\n  it('returns default value for left', () => {\n    const result = getUserName(userLeft)\n    expect(result).toEqual('Anonymous')\n  })\n})"
  },
  {
    "id": "either-08",
    "title": "Map Left",
    "description": "Learn about map left in fp-ts either",
    "category": "Either",
    "fileName": "08-map-left.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype ErrorCode = 'ERR_NOT_FOUND' | 'ERR_INVALID_ID'\n\ninterface DetailedError {\n  code: ErrorCode\n  message: string\n  timestamp: number\n}\n\n// @ts-ignore\nconst enrichError = (\n  userEither: E.Either<ErrorCode, User>\n): E.Either<DetailedError, User> => {\n  //TODO:\n  //Use E.mapLeft to transform the error from ErrorCode to DetailedError\n  //Create a DetailedError object with:\n  // - code: the original error code\n  // - message: a user-friendly message based on the error code\n  // - timestamp: Date.now()\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype ErrorCode = 'ERR_NOT_FOUND' | 'ERR_INVALID_ID'\n\ninterface DetailedError {\n  code: ErrorCode\n  message: string\n  timestamp: number\n}\n\nexport const enrichError = (\n  userEither: E.Either<ErrorCode, User>\n): E.Either<DetailedError, User> =>\n  pipe(\n    userEither,\n    E.mapLeft((errorCode): DetailedError => ({\n      code: errorCode,\n      message: errorCode === 'ERR_NOT_FOUND' ? 'User not found' : 'Invalid user ID',\n      timestamp: Date.now()\n    }))\n  )",
    "testCode": "describe('enrichError', () => {\n  const userRight: E.Either<ErrorCode, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft1: E.Either<ErrorCode, User> = E.left('ERR_NOT_FOUND')\n  const userLeft2: E.Either<ErrorCode, User> = E.left('ERR_INVALID_ID')\n\n  it('preserves right value', () => {\n    const result = enrichError(userRight)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice' } })\n  })\n\n  it('enriches ERR_NOT_FOUND error', () => {\n    const result = enrichError(userLeft1)\n    expect(result._tag).toEqual('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.code).toEqual('ERR_NOT_FOUND')\n      expect(result.left.message).toEqual('User not found')\n      expect(typeof result.left.timestamp).toBe('number')\n    }\n  })\n\n  it('enriches ERR_INVALID_ID error', () => {\n    const result = enrichError(userLeft2)\n    expect(result._tag).toEqual('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.code).toEqual('ERR_INVALID_ID')\n      expect(result.left.message).toEqual('Invalid user ID')\n      expect(typeof result.left.timestamp).toBe('number')\n    }\n  })\n})"
  },
  {
    "id": "flow-01",
    "title": "Basic Flow",
    "description": "Learn about basic flow in fp-ts flow",
    "category": "Flow",
    "fileName": "01-basic-flow.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst toString = (n: number): string => `Result: ${n}`\n\n// @ts-ignore\nconst processNumber = flow(\n  //TODO:\n  //Use flow to create a reusable function that:\n  //1. doubles a number\n  //2. adds 10\n  //3. converts to string\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst toString = (n: number): string => `Result: ${n}`\n\nexport const processNumber = flow(\n  double,\n  addTen,\n  toString\n)",
    "testCode": "describe('processNumber', () => {\n  it('creates reusable function: (5 * 2) + 10 = \"Result: 20\"', () => {\n    const result = processNumber(5)\n    expect(result).toEqual('Result: 20')\n  })\n\n  it('creates reusable function: (3 * 2) + 10 = \"Result: 16\"', () => {\n    const result = processNumber(3)\n    expect(result).toEqual('Result: 16')\n  })\n\n  it('can be called multiple times', () => {\n    expect(processNumber(0)).toEqual('Result: 10')\n    expect(processNumber(10)).toEqual('Result: 30')\n  })\n})"
  },
  {
    "id": "flow-02",
    "title": "With Option",
    "description": "Learn about with option in fp-ts flow",
    "category": "Flow",
    "fileName": "02-with-option.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\n// @ts-ignore\nconst getUserEmailById = flow(\n  //TODO:\n  //Use flow to create a reusable function that:\n  //1. Takes an id (number)\n  //2. Finds the user (returns User | undefined)\n  //3. Converts to Option\n  //4. Maps to extract email\n  //Returns O.Option<string>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\nexport const getUserEmailById = flow(\n  (id: number) => users.find(u => u.id === id),\n  O.fromNullable,\n  O.map(user => user.email)\n)",
    "testCode": "describe('getUserEmailById', () => {\n  it('returns Some with email when user found', () => {\n    const result = getUserEmailById(1)\n    expect(result).toEqual({ _tag: 'Some', value: 'alice@example.com' })\n  })\n\n  it('returns None when user not found', () => {\n    const result = getUserEmailById(99)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('is reusable', () => {\n    expect(getUserEmailById(2)).toEqual({ _tag: 'Some', value: 'bob@example.com' })\n    expect(getUserEmailById(1)).toEqual({ _tag: 'Some', value: 'alice@example.com' })\n  })\n})"
  },
  {
    "id": "flow-03",
    "title": "Composing Flows",
    "description": "Learn about composing flows in fp-ts flow",
    "category": "Flow",
    "fileName": "03-composing-flows.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst trim = (s: string): string => s.trim()\nconst toLowerCase = (s: string): string => s.toLowerCase()\nconst splitWords = (s: string): string[] => s.split(' ')\nconst countWords = (words: string[]): number => words.length\n\n// @ts-ignore\nconst normalizeText = flow(\n  //TODO: Create a flow that trims and converts to lowercase\n)\n\n// @ts-ignore\nconst countWordsInText = flow(\n  //TODO: Create a flow that normalizes text, splits into words, and counts them\n  //Hint: You can compose flows together!\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst trim = (s: string): string => s.trim()\nconst toLowerCase = (s: string): string => s.toLowerCase()\nconst splitWords = (s: string): string[] => s.split(' ')\nconst countWords = (words: string[]): number => words.length\n\nexport const normalizeText = flow(\n  trim,\n  toLowerCase\n)\n\nexport const countWordsInText = flow(\n  normalizeText,\n  splitWords,\n  countWords\n)",
    "testCode": "describe('text processing flows', () => {\n  it('normalizes text', () => {\n    const result = normalizeText('  Hello WORLD  ')\n    expect(result).toEqual('hello world')\n  })\n\n  it('counts words in text', () => {\n    const result = countWordsInText('  Hello WORLD  ')\n    expect(result).toEqual(2)\n  })\n\n  it('counts words in longer text', () => {\n    const result = countWordsInText('  The Quick Brown FOX  ')\n    expect(result).toEqual(4)\n  })\n\n  it('handles single word', () => {\n    const result = countWordsInText('  Hello  ')\n    expect(result).toEqual(1)\n  })\n})"
  },
  {
    "id": "flow-04",
    "title": "With Either",
    "description": "Learn about with either in fp-ts flow",
    "category": "Flow",
    "fileName": "04-with-either.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ntype ValidationError = 'Empty string' | 'Too short' | 'Invalid format'\n\nconst validateNotEmpty = (s: string): E.Either<ValidationError, string> =>\n  s.length > 0 ? E.right(s) : E.left('Empty string')\n\nconst validateMinLength = (min: number) => (s: string): E.Either<ValidationError, string> =>\n  s.length >= min ? E.right(s) : E.left('Too short')\n\nconst validateEmail = (s: string): E.Either<ValidationError, string> =>\n  s.includes('@') ? E.right(s) : E.left('Invalid format')\n\n// @ts-ignore\nconst validateEmailAddress = flow(\n  //TODO:\n  //Use flow to create an email validation function that:\n  //1. Validates not empty\n  //2. Chains to validate min length of 5\n  //3. Chains to validate email format\n  //Return E.Either<ValidationError, string>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = 'Empty string' | 'Too short' | 'Invalid format'\n\nconst validateNotEmpty = (s: string): E.Either<ValidationError, string> =>\n  s.length > 0 ? E.right(s) : E.left('Empty string')\n\nconst validateMinLength = (min: number) => (s: string): E.Either<ValidationError, string> =>\n  s.length >= min ? E.right(s) : E.left('Too short')\n\nconst validateEmail = (s: string): E.Either<ValidationError, string> =>\n  s.includes('@') ? E.right(s) : E.left('Invalid format')\n\nexport const validateEmailAddress = flow(\n  validateNotEmpty,\n  E.chain(validateMinLength(5)),\n  E.chain(validateEmail)\n)",
    "testCode": "describe('validateEmailAddress', () => {\n  it('accepts valid email', () => {\n    const result = validateEmailAddress('test@example.com')\n    expect(result).toEqual({ _tag: 'Right', right: 'test@example.com' })\n  })\n\n  it('rejects empty string', () => {\n    const result = validateEmailAddress('')\n    expect(result).toEqual({ _tag: 'Left', left: 'Empty string' })\n  })\n\n  it('rejects too short', () => {\n    const result = validateEmailAddress('a@b')\n    expect(result).toEqual({ _tag: 'Left', left: 'Too short' })\n  })\n\n  it('rejects invalid format', () => {\n    const result = validateEmailAddress('notanemail')\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid format' })\n  })\n})"
  },
  {
    "id": "flow-05",
    "title": "Practical Example",
    "description": "Learn about practical example in fp-ts flow",
    "category": "Flow",
    "fileName": "05-practical-example.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface RawUserData {\n  email: string\n  age: string\n  name: string\n}\n\ninterface User {\n  email: string\n  age: number\n  name: string\n}\n\ntype ParseError = 'Invalid email' | 'Invalid age' | 'Name too short'\n\nconst validateEmail = (data: RawUserData): E.Either<ParseError, RawUserData> =>\n  data.email.includes('@') ? E.right(data) : E.left('Invalid email')\n\nconst parseAge = (data: RawUserData): E.Either<ParseError, { email: string; age: number; name: string }> => {\n  const age = parseInt(data.age, 10)\n  return isNaN(age) ? E.left('Invalid age') : E.right({ ...data, age })\n}\n\nconst validateName = (data: { email: string; age: number; name: string }): E.Either<ParseError, User> =>\n  data.name.length >= 2 ? E.right(data) : E.left('Name too short')\n\n// @ts-ignore\nconst parseUser = flow(\n  //TODO:\n  //Create a flow that validates and parses raw user data:\n  //1. Validate email\n  //2. Chain to parse age\n  //3. Chain to validate name\n  //Returns E.Either<ParseError, User>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface RawUserData {\n  email: string\n  age: string\n  name: string\n}\n\ninterface User {\n  email: string\n  age: number\n  name: string\n}\n\ntype ParseError = 'Invalid email' | 'Invalid age' | 'Name too short'\n\nconst validateEmail = (data: RawUserData): E.Either<ParseError, RawUserData> =>\n  data.email.includes('@') ? E.right(data) : E.left('Invalid email')\n\nconst parseAge = (data: RawUserData): E.Either<ParseError, { email: string; age: number; name: string }> => {\n  const age = parseInt(data.age, 10)\n  return isNaN(age) ? E.left('Invalid age') : E.right({ ...data, age })\n}\n\nconst validateName = (data: { email: string; age: number; name: string }): E.Either<ParseError, User> =>\n  data.name.length >= 2 ? E.right(data) : E.left('Name too short')\n\nexport const parseUser = flow(\n  validateEmail,\n  E.chain(parseAge),\n  E.chain(validateName)\n)",
    "testCode": "describe('parseUser', () => {\n  it('successfully parses valid user data', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: '25',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({\n      _tag: 'Right',\n      right: { email: 'alice@example.com', age: 25, name: 'Alice' }\n    })\n  })\n\n  it('rejects invalid email', () => {\n    const rawData: RawUserData = {\n      email: 'notanemail',\n      age: '25',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid email' })\n  })\n\n  it('rejects invalid age', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: 'not a number',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid age' })\n  })\n\n  it('rejects too short name', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: '25',\n      name: 'A'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Name too short' })\n  })\n})"
  },
  {
    "id": "monoid-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts monoid",
    "category": "Monoid",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as Str from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst sumAllNumbers = (numbers: number[]): number => {\n  //TODO: Use M.concatAll with N.MonoidSum to sum numbers\n  //HINT: Unlike Semigroup, Monoid has an empty value, so it works with empty arrays\n}\n\n// @ts-ignore\nconst joinStrings = (strings: string[]): string => {\n  //TODO: Use M.concatAll with Str.Monoid to concatenate strings\n  //HINT: Str.Monoid has empty = \"\"\n}",
    "solutionCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as Str from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\nexport const sumAllNumbers = (numbers: number[]): number =>\n  M.concatAll(N.MonoidSum)(numbers)\n\nexport const joinStrings = (strings: string[]): string =>\n  M.concatAll(Str.Monoid)(strings)",
    "testCode": "describe('Monoid basics', () => {\n  it('sums numbers including empty array', () => {\n    expect(sumAllNumbers([1, 2, 3, 4, 5])).toBe(15)\n    expect(sumAllNumbers([])).toBe(0) // Returns identity element\n  })\n\n  it('joins strings including empty array', () => {\n    expect(joinStrings(['Hello', 'World'])).toBe('HelloWorld')\n    expect(joinStrings([])).toBe('') // Returns identity element\n  })\n\n  it('handles single element', () => {\n    expect(sumAllNumbers([42])).toBe(42)\n    expect(joinStrings(['solo'])).toBe('solo')\n  })\n})"
  },
  {
    "id": "monoid-02",
    "title": "Struct",
    "description": "Learn about struct in fp-ts monoid",
    "category": "Monoid",
    "fileName": "02-struct.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as Str from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\ntype ShoppingCart = {\n  items: number\n  totalPrice: number\n  couponCode: string\n}\n\n// @ts-ignore\nconst combineCart = (carts: ShoppingCart[]): ShoppingCart => {\n  //TODO: Create a Monoid for ShoppingCart that:\n  // - Sums items and totalPrice\n  // - Keeps the first non-empty couponCode\n  //HINT: Use M.struct with appropriate monoids for each field\n}",
    "solutionCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as Str from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\ntype ShoppingCart = {\n  items: number\n  totalPrice: number\n  couponCode: string\n}\n\nconst ShoppingCartMonoid: M.Monoid<ShoppingCart> = M.struct({\n  items: N.MonoidSum,\n  totalPrice: N.MonoidSum,\n  couponCode: Str.Monoid,\n})\n\nexport const combineCart = (carts: ShoppingCart[]): ShoppingCart =>\n  M.concatAll(ShoppingCartMonoid)(carts)",
    "testCode": "describe('Monoid struct', () => {\n  it('combines multiple carts', () => {\n    const carts = [\n      { items: 3, totalPrice: 50, couponCode: '' },\n      { items: 2, totalPrice: 30, couponCode: 'SAVE10' },\n      { items: 1, totalPrice: 20, couponCode: '' },\n    ]\n    const result = combineCart(carts)\n    expect(result).toEqual({\n      items: 6,\n      totalPrice: 100,\n      couponCode: 'SAVE10',\n    })\n  })\n\n  it('handles empty array', () => {\n    const result = combineCart([])\n    expect(result).toEqual({\n      items: 0,\n      totalPrice: 0,\n      couponCode: '',\n    })\n  })\n\n  it('handles single cart', () => {\n    const result = combineCart([{ items: 5, totalPrice: 75, couponCode: 'FIRST' }])\n    expect(result).toEqual({ items: 5, totalPrice: 75, couponCode: 'FIRST' })\n  })\n})"
  },
  {
    "id": "monoid-03",
    "title": "Custom",
    "description": "Learn about custom in fp-ts monoid",
    "category": "Monoid",
    "fileName": "03-custom.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as M from 'fp-ts/Monoid'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst MaxMonoid: M.Monoid<number> = {\n  //TODO: Create a Monoid that keeps the maximum number\n  //HINT: concat should return max(x, y), empty should be -Infinity\n  concat: (x, y) => 0, // TODO\n  empty: 0, // TODO\n}\n\n// @ts-ignore\nconst combineMax = (numbers: number[]): number => {\n  //TODO: Use MaxMonoid to find the maximum\n}\n\n// @ts-ignore\nconst ArrayMonoid = <T>(): M.Monoid<T[]> => ({\n  //TODO: Create a Monoid for arrays that concatenates them\n  //HINT: concat should use [...x, ...y], empty should be []\n  concat: (x, y) => [], // TODO\n  empty: [], // TODO\n})\n\n// @ts-ignore\nconst flattenArrays = <T>(arrays: T[][]): T[] => {\n  //TODO: Use ArrayMonoid to flatten nested arrays\n}",
    "solutionCode": "import * as M from 'fp-ts/Monoid'\nimport { describe, it, expect } from 'vitest'\n\nexport const MaxMonoid: M.Monoid<number> = {\n  concat: (x, y) => Math.max(x, y),\n  empty: -Infinity,\n}\n\nexport const combineMax = (numbers: number[]): number =>\n  M.concatAll(MaxMonoid)(numbers)\n\nexport const ArrayMonoid = <T>(): M.Monoid<T[]> => ({\n  concat: (x, y) => [...x, ...y],\n  empty: [],\n})\n\nexport const flattenArrays = <T>(arrays: T[][]): T[] =>\n  M.concatAll(ArrayMonoid<T>())(arrays)",
    "testCode": "describe('Custom Monoids', () => {\n  it('finds maximum with MaxMonoid', () => {\n    expect(combineMax([3, 7, 2, 9, 1])).toBe(9)\n    expect(combineMax([5])).toBe(5)\n    expect(combineMax([])).toBe(-Infinity)\n  })\n\n  it('flattens arrays with ArrayMonoid', () => {\n    const result = flattenArrays([[1, 2], [3, 4], [5]])\n    expect(result).toEqual([1, 2, 3, 4, 5])\n  })\n\n  it('handles empty nested arrays', () => {\n    expect(flattenArrays([])).toEqual([])\n    expect(flattenArrays([[], [], []])).toEqual([])\n  })\n})"
  },
  {
    "id": "monoid-04",
    "title": "Practical",
    "description": "Learn about practical in fp-ts monoid",
    "category": "Monoid",
    "fileName": "04-practical.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as B from 'fp-ts/boolean'\nimport { describe, it, expect } from 'vitest'\n\ntype PageMetrics = {\n  views: number\n  likes: number\n  shares: number\n  comments: number\n}\n\n// @ts-ignore\nconst aggregateMetrics = (metrics: PageMetrics[]): PageMetrics => {\n  //TODO: Aggregate all metrics by summing each field\n  //HINT: Use M.struct with N.MonoidSum for all fields\n}\n\ntype FeatureFlags = {\n  darkMode: boolean\n  notifications: boolean\n  analytics: boolean\n}\n\n// @ts-ignore\nconst combineFeatureFlags = (flags: FeatureFlags[]): FeatureFlags => {\n  //TODO: Combine feature flags where ANY true enables the feature\n  //HINT: Use M.struct with B.MonoidAny (logical OR)\n}",
    "solutionCode": "import * as M from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\nimport * as B from 'fp-ts/boolean'\nimport { describe, it, expect } from 'vitest'\n\ntype PageMetrics = {\n  views: number\n  likes: number\n  shares: number\n  comments: number\n}\n\nconst PageMetricsMonoid: M.Monoid<PageMetrics> = M.struct({\n  views: N.MonoidSum,\n  likes: N.MonoidSum,\n  shares: N.MonoidSum,\n  comments: N.MonoidSum,\n})\n\nexport const aggregateMetrics = (metrics: PageMetrics[]): PageMetrics =>\n  M.concatAll(PageMetricsMonoid)(metrics)\n\ntype FeatureFlags = {\n  darkMode: boolean\n  notifications: boolean\n  analytics: boolean\n}\n\nconst FeatureFlagsMonoid: M.Monoid<FeatureFlags> = M.struct({\n  darkMode: B.MonoidAny,\n  notifications: B.MonoidAny,\n  analytics: B.MonoidAny,\n})\n\nexport const combineFeatureFlags = (flags: FeatureFlags[]): FeatureFlags =>\n  M.concatAll(FeatureFlagsMonoid)(flags)",
    "testCode": "describe('Monoid practical examples', () => {\n  it('aggregates page metrics', () => {\n    const metrics = [\n      { views: 100, likes: 10, shares: 5, comments: 3 },\n      { views: 200, likes: 20, shares: 8, comments: 7 },\n      { views: 150, likes: 15, shares: 3, comments: 5 },\n    ]\n    const result = aggregateMetrics(metrics)\n    expect(result).toEqual({\n      views: 450,\n      likes: 45,\n      shares: 16,\n      comments: 15,\n    })\n  })\n\n  it('handles empty metrics', () => {\n    const result = aggregateMetrics([])\n    expect(result).toEqual({ views: 0, likes: 0, shares: 0, comments: 0 })\n  })\n\n  it('combines feature flags with OR logic', () => {\n    const flags = [\n      { darkMode: false, notifications: true, analytics: false },\n      { darkMode: true, notifications: false, analytics: false },\n      { darkMode: false, notifications: false, analytics: true },\n    ]\n    const result = combineFeatureFlags(flags)\n    expect(result).toEqual({\n      darkMode: true, // At least one true\n      notifications: true,\n      analytics: true,\n    })\n  })\n\n  it('handles all false flags', () => {\n    const flags = [\n      { darkMode: false, notifications: false, analytics: false },\n      { darkMode: false, notifications: false, analytics: false },\n    ]\n    const result = combineFeatureFlags(flags)\n    expect(result).toEqual({ darkMode: false, notifications: false, analytics: false })\n  })\n})"
  },
  {
    "id": "nonemptyarray-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst createNonEmpty = (first: number, rest: number[]): NEA.NonEmptyArray<number> => {\n  //TODO: Create a NonEmptyArray from a first element and rest\n  //HINT: NEA.fromArray or NEA.cons or direct construction [first, ...rest]\n}\n\n// @ts-ignore\nconst safeHead = (arr: NEA.NonEmptyArray<number>): number => {\n  //TODO: Get the first element (head) - no Option needed!\n  //HINT: NEA.head\n}\n\n// @ts-ignore\nconst safeLast = (arr: NEA.NonEmptyArray<number>): number => {\n  //TODO: Get the last element - no Option needed!\n  //HINT: NEA.last\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport { describe, it, expect } from 'vitest'\n\nexport const createNonEmpty = (first: number, rest: number[]): NEA.NonEmptyArray<number> => [first, ...rest]\n\nexport const safeHead = (arr: NEA.NonEmptyArray<number>): number => NEA.head(arr)\n\nexport const safeLast = (arr: NEA.NonEmptyArray<number>): number => NEA.last(arr)",
    "testCode": "describe('NonEmptyArray basics', () => {\n  it('creates non-empty array', () => {\n    const result = createNonEmpty(1, [2, 3, 4])\n    expect(result).toEqual([1, 2, 3, 4])\n    expect(result.length).toBeGreaterThan(0)\n  })\n\n  it('safely gets head', () => {\n    const arr = NEA.of(42)\n    expect(safeHead(arr)).toBe(42)\n  })\n\n  it('safely gets last', () => {\n    const arr: NEA.NonEmptyArray<number> = [1, 2, 3, 4, 5]\n    expect(safeLast(arr)).toBe(5)\n  })\n\n  it('head and last same for single element', () => {\n    const arr = NEA.of(99)\n    expect(safeHead(arr)).toBe(99)\n    expect(safeLast(arr)).toBe(99)\n  })\n})"
  },
  {
    "id": "nonemptyarray-02",
    "title": "From Array",
    "description": "Learn about from array in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "02-from-array.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst fromArraySafe = (arr: number[]): O.Option<NEA.NonEmptyArray<number>> => {\n  //TODO: Convert a regular array to NonEmptyArray (returns Option because array might be empty)\n  //HINT: Use NEA.fromArray\n}\n\n// @ts-ignore\nconst getFirstOrDefault = (arr: number[], defaultValue: number): number => {\n  //TODO: Try to convert to NonEmptyArray and get head, or return default\n  //HINT: Use NEA.fromArray, then O.map with NEA.head, then O.getOrElse\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const fromArraySafe = (arr: number[]): O.Option<NEA.NonEmptyArray<number>> =>\n  NEA.fromArray(arr)\n\nexport const getFirstOrDefault = (arr: number[], defaultValue: number): number =>\n  pipe(\n    NEA.fromArray(arr),\n    O.map(NEA.head),\n    O.getOrElse(() => defaultValue)\n  )",
    "testCode": "describe('NonEmptyArray from array', () => {\n  it('converts non-empty array', () => {\n    const result = fromArraySafe([1, 2, 3])\n    expect(O.isSome(result)).toBe(true)\n    if (O.isSome(result)) {\n      expect(result.value).toEqual([1, 2, 3])\n    }\n  })\n\n  it('returns None for empty array', () => {\n    const result = fromArraySafe([])\n    expect(O.isNone(result)).toBe(true)\n  })\n\n  it('gets first or default', () => {\n    expect(getFirstOrDefault([5, 10, 15], 0)).toBe(5)\n    expect(getFirstOrDefault([], 99)).toBe(99)\n  })\n})"
  },
  {
    "id": "nonemptyarray-03",
    "title": "Operations",
    "description": "Learn about operations in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "03-operations.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst mapNonEmpty = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> => {\n  //TODO: Map over NonEmptyArray to double each number\n  //HINT: NEA.map works like Array.map but preserves non-emptiness\n}\n\n// @ts-ignore\nconst concatNonEmpty = (arr1: NEA.NonEmptyArray<number>, arr2: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> => {\n  //TODO: Concatenate two NonEmptyArrays\n  //HINT: Use NEA.concat or spread operator\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const mapNonEmpty = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> =>\n  pipe(\n    arr,\n    NEA.map((n) => n * 2)\n  )\n\nexport const concatNonEmpty = (arr1: NEA.NonEmptyArray<number>, arr2: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> =>\n  NEA.concat(arr2)(arr1)",
    "testCode": "describe('NonEmptyArray operations', () => {\n  it('maps over non-empty array', () => {\n    const arr: NEA.NonEmptyArray<number> = [1, 2, 3]\n    const result = mapNonEmpty(arr)\n    expect(result).toEqual([2, 4, 6])\n  })\n\n  it('concatenates non-empty arrays', () => {\n    const arr1: NEA.NonEmptyArray<number> = [1, 2]\n    const arr2: NEA.NonEmptyArray<number> = [3, 4]\n    const result = concatNonEmpty(arr1, arr2)\n    expect(result).toEqual([1, 2, 3, 4])\n  })\n\n  it('concat preserves non-emptiness', () => {\n    const arr1 = NEA.of(1)\n    const arr2 = NEA.of(2)\n    const result = concatNonEmpty(arr1, arr2)\n    expect(result.length).toBeGreaterThan(0)\n  })\n})"
  },
  {
    "id": "nonemptyarray-04",
    "title": "Sort",
    "description": "Learn about sort in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "04-sort.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst sortNumbers = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> => {\n  //TODO: Sort NonEmptyArray of numbers\n  //HINT: Use NEA.sort with N.Ord\n}\n\n// @ts-ignore\nconst sortStrings = (arr: NEA.NonEmptyArray<string>): NEA.NonEmptyArray<string> => {\n  //TODO: Sort NonEmptyArray of strings\n  //HINT: Use NEA.sort with S.Ord\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const sortNumbers = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<number> =>\n  pipe(arr, NEA.sort(N.Ord))\n\nexport const sortStrings = (arr: NEA.NonEmptyArray<string>): NEA.NonEmptyArray<string> =>\n  pipe(arr, NEA.sort(S.Ord))",
    "testCode": "describe('NonEmptyArray sort', () => {\n  it('sorts numbers', () => {\n    const arr: NEA.NonEmptyArray<number> = [5, 2, 8, 1, 9]\n    const result = sortNumbers(arr)\n    expect(result).toEqual([1, 2, 5, 8, 9])\n  })\n\n  it('sorts strings', () => {\n    const arr: NEA.NonEmptyArray<string> = ['zebra', 'apple', 'mango']\n    const result = sortStrings(arr)\n    expect(result).toEqual(['apple', 'mango', 'zebra'])\n  })\n\n  it('preserves non-emptiness after sort', () => {\n    const arr = NEA.of(42)\n    const result = sortNumbers(arr)\n    expect(result.length).toBeGreaterThan(0)\n  })\n})"
  },
  {
    "id": "nonemptyarray-05",
    "title": "Group",
    "description": "Learn about group in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "05-group.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as Eq from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst groupConsecutive = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<NEA.NonEmptyArray<number>> => {\n  //TODO: Group consecutive equal numbers\n  //HINT: Use NEA.group with N.Eq\n}\n\n// @ts-ignore\nconst groupByParity = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<NEA.NonEmptyArray<number>> => {\n  //TODO: Group numbers by parity (odd/even) consecutively\n  //HINT: Create custom Eq that checks if both are odd or both are even\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as Eq from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\nexport const groupConsecutive = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<NEA.NonEmptyArray<number>> =>\n  NEA.group(N.Eq)(arr)\n\nconst ParityEq: Eq.Eq<number> = {\n  equals: (x, y) => x % 2 === y % 2,\n}\n\nexport const groupByParity = (arr: NEA.NonEmptyArray<number>): NEA.NonEmptyArray<NEA.NonEmptyArray<number>> =>\n  NEA.group(ParityEq)(arr)",
    "testCode": "describe('NonEmptyArray grouping', () => {\n  it('groups consecutive equal numbers', () => {\n    const arr: NEA.NonEmptyArray<number> = [1, 1, 2, 2, 2, 3, 1]\n    const result = groupConsecutive(arr)\n    expect(result).toEqual([[1, 1], [2, 2, 2], [3], [1]])\n  })\n\n  it('groups by parity', () => {\n    const arr: NEA.NonEmptyArray<number> = [1, 3, 5, 2, 4, 7, 9]\n    const result = groupByParity(arr)\n    expect(result).toEqual([[1, 3, 5], [2, 4], [7, 9]])\n  })\n\n  it('single element creates single group', () => {\n    const arr = NEA.of(42)\n    const result = groupConsecutive(arr)\n    expect(result).toEqual([[42]])\n  })\n})"
  },
  {
    "id": "nonemptyarray-06",
    "title": "Practical",
    "description": "Learn about practical in fp-ts nonemptyarray",
    "category": "Nonemptyarray",
    "fileName": "06-practical.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as O from 'fp-ts/Option'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype LogEntry = {\n  timestamp: number\n  message: string\n  level: 'info' | 'warn' | 'error'\n}\n\n// @ts-ignore\nconst getLatestLog = (logs: LogEntry[]): O.Option<LogEntry> => {\n  //TODO: Get the most recent log (last element) safely\n  //HINT: Convert to NonEmptyArray, then use NEA.last\n}\n\n// @ts-ignore\nconst getErrorLogs = (logs: NEA.NonEmptyArray<LogEntry>): O.Option<NEA.NonEmptyArray<LogEntry>> => {\n  //TODO: Filter to only error logs\n  //HINT: Use NEA.filter (returns Option because filter might result in empty)\n}\n\n// @ts-ignore\nconst getMostRecentError = (logs: NEA.NonEmptyArray<LogEntry>): O.Option<LogEntry> => {\n  //TODO: Get the most recent error log\n  //HINT: Use getErrorLogs, then O.map with NEA.last\n}",
    "solutionCode": "import * as NEA from 'fp-ts/NonEmptyArray'\nimport * as O from 'fp-ts/Option'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype LogEntry = {\n  timestamp: number\n  message: string\n  level: 'info' | 'warn' | 'error'\n}\n\nexport const getLatestLog = (logs: LogEntry[]): O.Option<LogEntry> =>\n  pipe(\n    NEA.fromArray(logs),\n    O.map(NEA.last)\n  )\n\nexport const getErrorLogs = (logs: NEA.NonEmptyArray<LogEntry>): O.Option<NEA.NonEmptyArray<LogEntry>> =>\n  NEA.filter((log: LogEntry) => log.level === 'error')(logs)\n\nexport const getMostRecentError = (logs: NEA.NonEmptyArray<LogEntry>): O.Option<LogEntry> =>\n  pipe(\n    getErrorLogs(logs),\n    O.map(NEA.last)\n  )",
    "testCode": "describe('NonEmptyArray practical examples', () => {\n  const logs: LogEntry[] = [\n    { timestamp: 1, message: 'Started', level: 'info' },\n    { timestamp: 2, message: 'Warning!', level: 'warn' },\n    { timestamp: 3, message: 'Failed', level: 'error' },\n    { timestamp: 4, message: 'Completed', level: 'info' },\n  ]\n\n  it('gets latest log', () => {\n    const result = getLatestLog(logs)\n    expect(O.isSome(result)).toBe(true)\n    if (O.isSome(result)) {\n      expect(result.value.timestamp).toBe(4)\n    }\n  })\n\n  it('returns None for empty logs', () => {\n    const result = getLatestLog([])\n    expect(O.isNone(result)).toBe(true)\n  })\n\n  it('filters error logs', () => {\n    const nonEmptyLogs = NEA.fromArray(logs)\n    expect(O.isSome(nonEmptyLogs)).toBe(true)\n    if (O.isSome(nonEmptyLogs)) {\n      const result = getErrorLogs(nonEmptyLogs.value)\n      expect(O.isSome(result)).toBe(true)\n      if (O.isSome(result)) {\n        expect(result.value.length).toBe(1)\n        expect(result.value[0].level).toBe('error')\n      }\n    }\n  })\n\n  it('gets most recent error', () => {\n    const nonEmptyLogs = NEA.fromArray(logs)\n    expect(O.isSome(nonEmptyLogs)).toBe(true)\n    if (O.isSome(nonEmptyLogs)) {\n      const result = getMostRecentError(nonEmptyLogs.value)\n      expect(O.isSome(result)).toBe(true)\n      if (O.isSome(result)) {\n        expect(result.value.message).toBe('Failed')\n      }\n    }\n  })\n})"
  },
  {
    "id": "option-01",
    "title": "Some And None",
    "description": "Learn about some and none in fp-ts option",
    "category": "Option",
    "fileName": "01-some-and-none.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\n// @ts-ignore\nconst getUserById = (users: User[], id: number): O.Option<User> => {\n  //TODO:\n  //Use the find method to search for the user in the users array that has the matching id.\n  //If the find method returns a user, return an option with the user wrapped in some.\n  //If the find method doesn't return a user, return an option with O.none.\n}",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\nexport const getUserById = (users: User[], id: number): O.Option<User> => {\n  const user = users.find(u => u.id === id)\n  return user ? O.some(user) : O.none\n}",
    "testCode": "describe('getUserById', () => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' },\n  ]\n\n  it('returns an option with user if it exists', () => {\n    const user = getUserById(users, 2)\n    expect(user).toEqual({ _tag: 'Some', value: { id: 2, name: 'Bob' } })\n  })\n\n  it('returns O.none if user does not exist', () => {\n    const user = getUserById(users, 4)\n    expect(user).toEqual({ _tag: 'None' })\n  })\n})"
  },
  {
    "id": "option-02",
    "title": "Of",
    "description": "Learn about of in fp-ts option",
    "category": "Option",
    "fileName": "02-of.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  //@ts-ignore\n  (user: User): O.Option<User> => {\n    //Create an option from a user.\n    //If the user has the same age as the given age, return an option with the user wrapped in some.\n    //If the user does not have the same age as the given age, return an option with O.none.\n    //Use the of function from the option module.\n  }",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  (user: User): O.Option<User> => {\n    return user.age === age ? O.of(user) : O.none\n  }",
    "testCode": "describe('createUserOptionFromAge', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30 }\n\n  it('returns some if user has same age as given age', () => {\n    const result = createUserOptionFromAge(30)(user2)\n    expect(result).toEqual(O.some(user2))\n  })\n\n  it('returns O.none if user does not have same age as given age', () => {\n    const result = createUserOptionFromAge(20)(user1)\n    expect(result).toEqual(O.none)\n  })\n})\n"
  },
  {
    "id": "option-03",
    "title": "From Predicate",
    "description": "Learn about from predicate in fp-ts option",
    "category": "Option",
    "fileName": "03-from-predicate.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  //@ts-ignore\n  (user: User): O.Option<User> => {\n    //Create a function that returns an option from a user.\n    //If the user has the same age as the given age, return an option with the user wrapped in some.\n    //If the user does not have the same age as the given age, return an option with O.none.\n    //Use the fromPredicate function from the option module.\n  }",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  (user: User): O.Option<User> => {\n    const isUserAge = (u: User) => u.age === age\n    return pipe(user, O.fromPredicate(isUserAge))\n  }",
    "testCode": "describe('createUserOptionFromAge', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30 }\n\n  it('returns some if user has same age as given age', () => {\n    const result = createUserOptionFromAge(30)(user2)\n    expect(result).toEqual(O.some(user2))\n  })\n\n  it('returns O.none if user does not have same age as given age', () => {\n    const result = createUserOptionFromAge(20)(user1)\n    expect(result).toEqual(O.none)\n  })\n})"
  },
  {
    "id": "option-04",
    "title": "Fold",
    "description": "Learn about fold in fp-ts option",
    "category": "Option",
    "fileName": "04-fold.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\n// @ts-ignore\nconst getUserEmail = (user: O.Option<User>): string => {\n  // Use the fold method on the Option object to handle both the some and O.none cases.\n  //In the some case, extract the email property from the User object and return it.\n  //In the O.none case, return a default message.\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst getUserEmail = (user: O.Option<User>): string =>\n  pipe(\n    user,\n    O.fold(\n      () => 'User email not available',\n      (user: User) => user.email\n    )\n  )",
    "testCode": "describe('getUserEmail', () => {\n  const user1: O.Option<User> = O.some({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n  })\n  const user2: O.Option<User> = O.none\n\n  it('returns user email if available', () => {\n    const result = getUserEmail(user1)\n    expect(result).toEqual('alice@example.com')\n  })\n\n  it('returns default message if user email is not available', () => {\n    const result = getUserEmail(user2)\n    expect(result).toEqual('User email not available')\n  })\n})"
  },
  {
    "id": "option-05",
    "title": "From Nullable",
    "description": "Learn about from nullable in fp-ts option",
    "category": "Option",
    "fileName": "05-from-nullable.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n  address?: string | null\n}\n\n//@ts-ignore\nconst getUserAddress = (user: User): O.Option<string> => {\n  //Create an Option from a nullable value using O.fromNullable()\n}",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n  address?: string | null\n}\n\nconst getUserAddress = (user: User): O.Option<string> => {\n  return O.fromNullable(user.address)\n}",
    "testCode": "describe('getUserAddress', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30, address: '123 Main St' }\n  const user3: User = { id: 3, name: 'Charlie', age: 35, address: null }\n\n  it('returns O.none if user has no address', () => {\n    const result = getUserAddress(user1)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns some with the address if user has an address', () => {\n    const result = getUserAddress(user2)\n    expect(result).toEqual({ _tag: 'Some', value: '123 Main St' })\n  })\n\n  it('returns O.none if user has a null address', () => {\n    const result = getUserAddress(user3)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})\n"
  },
  {
    "id": "option-06",
    "title": "To Nullable",
    "description": "Learn about to nullable in fp-ts option",
    "category": "Option",
    "fileName": "06-to-nullable.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddress = (addressOption: O.Option<string>): string | null => {\n  //Return null if addressOption is O.none and the address string if addressOption is some\n  //Use O.toNullable()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\nconst getAddress = (addressOption: O.Option<string>): string | null => {\n  return O.toNullable(addressOption)\n}",
    "testCode": "describe('getAddressString', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns null if address option is O.none', () => {\n    const result = getAddress(addressOption1)\n    expect(result).toBeNull()\n  })\n\n  it('returns the address string in the correct format if address option is some', () => {\n    const result = getAddress(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})"
  },
  {
    "id": "option-07",
    "title": "To Undefined",
    "description": "Learn about to undefined in fp-ts option",
    "category": "Option",
    "fileName": "07-to-undefined.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddress = (addressOption: O.Option<string>): string | undefined => {\n  //Return null if addressOption is O.none and the address string if addressOption is some\n  //Use O.toUndefined()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\nconst getAddress = (addressOption: O.Option<string>): string | undefined => {\n  return O.toUndefined(addressOption)\n}",
    "testCode": "describe('getAddress', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns undefined if address option is O.none', () => {\n    const result = getAddress(addressOption1)\n    expect(result).toBeUndefined()\n  })\n\n  it('returns the address string in the correct format if address option is some', () => {\n    const result = getAddress(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})\n"
  },
  {
    "id": "option-08",
    "title": "Get Or Else",
    "description": "Learn about get or else in fp-ts option",
    "category": "Option",
    "fileName": "08-get-or-else.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddressString = (addressOption: O.Option<string>): string => {\n  //Return 'No address provided' if addressOption is O.none and the address string if addressOption is some\n  //Use O.getOrElse()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst getAddressString = (addressOption: O.Option<string>): string => {\n  return pipe(\n    addressOption,\n    O.getOrElse(() => 'No address provided')\n  )\n}",
    "testCode": "describe('getAddressString', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns default string when address option is O.none', () => {\n    const result = getAddressString(addressOption1)\n    expect(result).toEqual('No address provided')\n  })\n\n  it('returns the address string in the correct format when address option is some', () => {\n    const result = getAddressString(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})\n"
  },
  {
    "id": "option-09",
    "title": "Filter",
    "description": "Learn about filter in fp-ts option",
    "category": "Option",
    "fileName": "09-filter.exercise.ts",
    "difficulty": "advanced",
    "order": 9,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getValidUserAddress = (address: O.Option<string>): O.Option<string> => {\n  //Return O.none if address is O.none and the address string if address is some\n  //Use O.filter()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst getValidUserAddress = (address: O.Option<string>): O.Option<string> =>\n  pipe(\n    address,\n    O.filter(address => address.length >= 5)\n  )",
    "testCode": "describe('getValidUserAddress', () => {\n  it('returns O.none if user has no address', () => {\n    const result = getValidUserAddress(O.none)\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns O.none if user has an address that is too short', () => {\n    const result = getValidUserAddress(O.of('456'))\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns the valid address if user has an address that is long enough', () => {\n    const result = getValidUserAddress(O.of('123 Main St'))\n    expect(result).toEqual(O.some('123 Main St'))\n  })\n})\n"
  },
  {
    "id": "option-10",
    "title": "From Either",
    "description": "Learn about from either in fp-ts option",
    "category": "Option",
    "fileName": "10-from-either.exercise.ts",
    "difficulty": "advanced",
    "order": 10,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst getUserById = (id: number): E.Either<string, User> => {\n  if (id < 1) {\n    return E.left('Invalid user ID')\n  }\n  return E.right({ id, name: `User ${id}`, age: id * 10 })\n}\n\n//@ts-ignore\nconst getUserOptionById = (id: number): O.Option<User> => {\n  //create a function that takes an id and returns an option of user using getUserById\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst getUserById = (id: number): E.Either<string, User> => {\n  if (id < 1) {\n    return E.left('Invalid user ID')\n  }\n  return E.right({ id, name: `User ${id}`, age: id * 10 })\n}\n\nconst getUserOptionById = (id: number): O.Option<User> =>\n  O.fromEither(getUserById(id))",
    "testCode": "describe('getUserOptionById', () => {\n  it('returns O.none if user ID is less than 1', () => {\n    const result = getUserOptionById(0)\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns a some object with the user if user ID is valid', () => {\n    const result = getUserOptionById(2)\n    expect(result).toEqual(O.some({ id: 2, name: 'User 2', age: 20 }))\n  })\n})\n"
  },
  {
    "id": "ord-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts ord",
    "category": "Ord",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst compareNumbers = (a: number, b: number): number => {\n  //TODO: Use Ord.compare with N.Ord to compare two numbers\n  //HINT: Ord.compare returns -1, 0, or 1\n}\n\n// @ts-ignore\nconst sortWords = (words: string[]): string[] => {\n  //TODO: Sort strings alphabetically using S.Ord\n  //HINT: Use Array.prototype.sort with Ord.compare\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\nexport const compareNumbers = (a: number, b: number): number =>\n  N.Ord.compare(a, b)\n\nexport const sortWords = (words: string[]): string[] =>\n  [...words].sort(S.Ord.compare)",
    "testCode": "describe('Ord basic', () => {\n  it('compares numbers', () => {\n    expect(compareNumbers(5, 10)).toBeLessThan(0)\n    expect(compareNumbers(10, 5)).toBeGreaterThan(0)\n    expect(compareNumbers(5, 5)).toBe(0)\n  })\n\n  it('sorts words alphabetically', () => {\n    const result = sortWords(['zebra', 'apple', 'banana'])\n    expect(result).toEqual(['apple', 'banana', 'zebra'])\n  })\n})"
  },
  {
    "id": "ord-02",
    "title": "Contramap",
    "description": "Learn about contramap in fp-ts ord",
    "category": "Ord",
    "fileName": "02-contramap.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Person = {\n  name: string\n  age: number\n}\n\n// @ts-ignore\nconst byAge: Ord.Ord<Person> = {\n  //TODO: Create an Ord for Person by age\n  //HINT: Use Ord.contramap to derive from N.Ord\n}\n\n// @ts-ignore\nconst byNameLength: Ord.Ord<Person> = {\n  //TODO: Create an Ord for Person by name length\n  //HINT: Use pipe with Ord.contramap\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Person = {\n  name: string\n  age: number\n}\n\nexport const byAge: Ord.Ord<Person> = pipe(\n  N.Ord,\n  Ord.contramap((p: Person) => p.age)\n)\n\nexport const byNameLength: Ord.Ord<Person> = pipe(\n  N.Ord,\n  Ord.contramap((p: Person) => p.name.length)\n)",
    "testCode": "describe('Ord contramap', () => {\n  it('sorts by age', () => {\n    const people: Person[] = [\n      { name: 'Alice', age: 30 },\n      { name: 'Bob', age: 25 },\n      { name: 'Charlie', age: 35 },\n    ]\n    const sorted = [...people].sort(byAge.compare)\n    expect(sorted[0].name).toBe('Bob')\n    expect(sorted[2].name).toBe('Charlie')\n  })\n\n  it('sorts by name length', () => {\n    const people: Person[] = [\n      { name: 'Alice', age: 30 },\n      { name: 'Bob', age: 25 },\n      { name: 'Charlie', age: 35 },\n    ]\n    const sorted = [...people].sort(byNameLength.compare)\n    expect(sorted[0].name).toBe('Bob')\n    expect(sorted[2].name).toBe('Charlie')\n  })\n})"
  },
  {
    "id": "ord-03",
    "title": "Reverse",
    "description": "Learn about reverse in fp-ts ord",
    "category": "Ord",
    "fileName": "03-reverse.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst sortDescending = (numbers: number[]): number[] => {\n  //TODO: Sort numbers in descending order\n  //HINT: Use Ord.reverse on N.Ord\n}\n\n// @ts-ignore\nconst sortWordsReverse = (words: string[]): string[] => {\n  //TODO: Sort strings in reverse alphabetical order\n  //HINT: pipe S.Ord through Ord.reverse\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const sortDescending = (numbers: number[]): number[] =>\n  [...numbers].sort(Ord.reverse(N.Ord).compare)\n\nexport const sortWordsReverse = (words: string[]): string[] =>\n  [...words].sort(pipe(S.Ord, Ord.reverse).compare)",
    "testCode": "describe('Ord reverse', () => {\n  it('sorts numbers descending', () => {\n    const result = sortDescending([3, 1, 4, 1, 5, 9])\n    expect(result).toEqual([9, 5, 4, 3, 1, 1])\n  })\n\n  it('sorts words reverse alphabetically', () => {\n    const result = sortWordsReverse(['apple', 'banana', 'cherry'])\n    expect(result).toEqual(['cherry', 'banana', 'apple'])\n  })\n})"
  },
  {
    "id": "ord-04",
    "title": "Min Max",
    "description": "Learn about min max in fp-ts ord",
    "category": "Ord",
    "fileName": "04-min-max.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype Product = {\n  name: string\n  price: number\n}\n\nconst byPrice: Ord.Ord<Product> = Ord.contramap((p: Product) => p.price)(N.Ord)\n\n// @ts-ignore\nconst getCheapest = (products: Product[]): Product => {\n  //TODO: Find the product with minimum price\n  //HINT: Use Ord.min with byPrice\n}\n\n// @ts-ignore\nconst getMostExpensive = (products: Product[]): Product => {\n  //TODO: Find the product with maximum price\n  //HINT: Use Ord.max with byPrice\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype Product = {\n  name: string\n  price: number\n}\n\nconst byPrice: Ord.Ord<Product> = Ord.contramap((p: Product) => p.price)(N.Ord)\n\nexport const getCheapest = (products: Product[]): Product =>\n  products.reduce(Ord.min(byPrice))\n\nexport const getMostExpensive = (products: Product[]): Product =>\n  products.reduce(Ord.max(byPrice))",
    "testCode": "describe('Ord min/max', () => {\n  const products: Product[] = [\n    { name: 'Laptop', price: 1000 },\n    { name: 'Mouse', price: 25 },\n    { name: 'Keyboard', price: 75 },\n  ]\n\n  it('finds cheapest product', () => {\n    const result = getCheapest(products)\n    expect(result.name).toBe('Mouse')\n  })\n\n  it('finds most expensive product', () => {\n    const result = getMostExpensive(products)\n    expect(result.name).toBe('Laptop')\n  })\n})"
  },
  {
    "id": "ord-05",
    "title": "Sort",
    "description": "Learn about sort in fp-ts ord",
    "category": "Ord",
    "fileName": "05-sort.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as A from 'fp-ts/Array'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype User = {\n  name: string\n  score: number\n}\n\n// @ts-ignore\nconst sortByScore = (users: User[]): User[] => {\n  //TODO: Sort users by score using A.sortBy\n  //HINT: Create Ord for score field, then use A.sortBy\n}\n\n// @ts-ignore\nconst clamp = (min: number, max: number, value: number): number => {\n  //TODO: Clamp value between min and max\n  //HINT: Use Ord.clamp with N.Ord\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as A from 'fp-ts/Array'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype User = {\n  name: string\n  score: number\n}\n\nconst byScore: Ord.Ord<User> = pipe(\n  N.Ord,\n  Ord.contramap((u: User) => u.score)\n)\n\nexport const sortByScore = (users: User[]): User[] =>\n  pipe(users, A.sortBy([byScore]))\n\nexport const clamp = (min: number, max: number, value: number): number =>\n  Ord.clamp(N.Ord)(min, max)(value)",
    "testCode": "describe('Ord sort', () => {\n  it('sorts users by score', () => {\n    const users: User[] = [\n      { name: 'Alice', score: 85 },\n      { name: 'Bob', score: 92 },\n      { name: 'Charlie', score: 78 },\n    ]\n    const result = sortByScore(users)\n    expect(result[0].name).toBe('Charlie')\n    expect(result[2].name).toBe('Bob')\n  })\n\n  it('clamps values', () => {\n    expect(clamp(0, 100, 50)).toBe(50)\n    expect(clamp(0, 100, -10)).toBe(0)\n    expect(clamp(0, 100, 150)).toBe(100)\n  })\n})"
  },
  {
    "id": "ord-06",
    "title": "Practical",
    "description": "Learn about practical in fp-ts ord",
    "category": "Ord",
    "fileName": "06-practical.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as Ord from 'fp-ts/Ord'\nimport * as A from 'fp-ts/Array'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Task = {\n  priority: number\n  name: string\n}\n\n// @ts-ignore\nconst sortTasks = (tasks: Task[]): Task[] => {\n  //TODO: Sort by priority (descending), then by name (ascending)\n  //HINT: Use A.sortBy with multiple Ord instances\n}\n\n// @ts-ignore\nconst isBetween = (min: number, max: number, value: number): boolean => {\n  //TODO: Check if value is between min and max (inclusive)\n  //HINT: Use Ord.between with N.Ord\n}",
    "solutionCode": "import * as Ord from 'fp-ts/Ord'\nimport * as A from 'fp-ts/Array'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype Task = {\n  priority: number\n  name: string\n}\n\nconst byPriorityDesc: Ord.Ord<Task> = pipe(\n  N.Ord,\n  Ord.contramap((t: Task) => t.priority),\n  Ord.reverse\n)\n\nconst byName: Ord.Ord<Task> = pipe(\n  S.Ord,\n  Ord.contramap((t: Task) => t.name)\n)\n\nexport const sortTasks = (tasks: Task[]): Task[] =>\n  pipe(tasks, A.sortBy([byPriorityDesc, byName]))\n\nexport const isBetween = (min: number, max: number, value: number): boolean =>\n  Ord.between(N.Ord)(min, max)(value)",
    "testCode": "describe('Ord practical', () => {\n  it('sorts tasks by priority then name', () => {\n    const tasks: Task[] = [\n      { priority: 2, name: 'Review PR' },\n      { priority: 1, name: 'Fix bug' },\n      { priority: 2, name: 'Deploy' },\n      { priority: 3, name: 'Meeting' },\n    ]\n    const result = sortTasks(tasks)\n\n    expect(result[0].priority).toBe(3)\n    expect(result[1].priority).toBe(2)\n    expect(result[1].name).toBe('Deploy')\n    expect(result[2].name).toBe('Review PR')\n  })\n\n  it('checks if value is between bounds', () => {\n    expect(isBetween(0, 10, 5)).toBe(true)\n    expect(isBetween(0, 10, 0)).toBe(true)\n    expect(isBetween(0, 10, 10)).toBe(true)\n    expect(isBetween(0, 10, -1)).toBe(false)\n    expect(isBetween(0, 10, 11)).toBe(false)\n  })\n})"
  },
  {
    "id": "pipe-01",
    "title": "Basic Pipe",
    "description": "Learn about basic pipe in fp-ts pipe",
    "category": "Pipe",
    "fileName": "01-basic-pipe.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst square = (n: number): number => n * n\n\n// @ts-ignore\nconst transform = (n: number): number => {\n  //TODO:\n  //Use pipe to compose the following operations in order:\n  //1. double the number\n  //2. add 10\n  //3. square the result\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst square = (n: number): number => n * n\n\nexport const transform = (n: number): number =>\n  pipe(\n    n,\n    double,\n    addTen,\n    square\n  )",
    "testCode": "describe('transform', () => {\n  it('applies transformations in correct order: (5 * 2 + 10)^2 = 400', () => {\n    const result = transform(5)\n    expect(result).toEqual(400)\n  })\n\n  it('applies transformations in correct order: (3 * 2 + 10)^2 = 256', () => {\n    const result = transform(3)\n    expect(result).toEqual(256)\n  })\n\n  it('applies transformations in correct order: (0 * 2 + 10)^2 = 100', () => {\n    const result = transform(0)\n    expect(result).toEqual(100)\n  })\n})"
  },
  {
    "id": "pipe-02",
    "title": "With Option",
    "description": "Learn about with option in fp-ts pipe",
    "category": "Pipe",
    "fileName": "02-with-option.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 30 },\n  { id: 3, name: 'Charlie', age: 35 },\n]\n\n// @ts-ignore\nconst getUserNameById = (id: number): O.Option<string> => {\n  //TODO:\n  //Use pipe to:\n  //1. Find the user by id (returns User | undefined)\n  //2. Convert to Option using O.fromNullable\n  //3. Map to extract the user's name\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 30 },\n  { id: 3, name: 'Charlie', age: 35 },\n]\n\nexport const getUserNameById = (id: number): O.Option<string> =>\n  pipe(\n    users.find(u => u.id === id),\n    O.fromNullable,\n    O.map(user => user.name)\n  )",
    "testCode": "describe('getUserNameById', () => {\n  it('returns Some with user name when found', () => {\n    const result = getUserNameById(2)\n    expect(result).toEqual({ _tag: 'Some', value: 'Bob' })\n  })\n\n  it('returns None when user not found', () => {\n    const result = getUserNameById(99)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})"
  },
  {
    "id": "pipe-03",
    "title": "With Either",
    "description": "Learn about with either in fp-ts pipe",
    "category": "Pipe",
    "fileName": "03-with-either.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserEmail = (id: number): E.Either<UserError, string> => {\n  //TODO:\n  //Use pipe to:\n  //1. Validate that id > 0 using E.fromPredicate (error: 'Invalid ID')\n  //2. Chain to find the user (error: 'User not found' if not found)\n  //3. Map to extract the email\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserEmail = (id: number): E.Either<UserError, string> =>\n  pipe(\n    id,\n    E.fromPredicate(\n      (id) => id > 0,\n      () => 'Invalid ID' as UserError\n    ),\n    E.chain((id) => {\n      const user = users.find(u => u.id === id)\n      return user ? E.right(user) : E.left('User not found' as UserError)\n    }),\n    E.map(user => user.email)\n  )",
    "testCode": "describe('getUserEmail', () => {\n  it('returns Right with email when user found', () => {\n    const result = getUserEmail(1)\n    expect(result).toEqual({ _tag: 'Right', right: 'alice@example.com' })\n  })\n\n  it('returns Left for invalid ID', () => {\n    const result = getUserEmail(0)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns Left when user not found', () => {\n    const result = getUserEmail(99)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "pipe-04",
    "title": "Array Operations",
    "description": "Learn about array operations in fp-ts pipe",
    "category": "Pipe",
    "fileName": "04-array-operations.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  inStock: boolean\n}\n\nconst products: Product[] = [\n  { id: 1, name: 'Laptop', price: 1000, inStock: true },\n  { id: 2, name: 'Mouse', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', price: 75, inStock: true },\n  { id: 4, name: 'Monitor', price: 300, inStock: true },\n  { id: 5, name: 'Webcam', price: 50, inStock: false },\n]\n\n// @ts-ignore\nconst getAffordableInStockProductNames = (maxPrice: number): string[] => {\n  //TODO:\n  //Use pipe with array methods to:\n  //1. Filter products that are inStock\n  //2. Filter products where price <= maxPrice\n  //3. Map to get product names\n  //4. Sort alphabetically\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  inStock: boolean\n}\n\nconst products: Product[] = [\n  { id: 1, name: 'Laptop', price: 1000, inStock: true },\n  { id: 2, name: 'Mouse', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', price: 75, inStock: true },\n  { id: 4, name: 'Monitor', price: 300, inStock: true },\n  { id: 5, name: 'Webcam', price: 50, inStock: false },\n]\n\nexport const getAffordableInStockProductNames = (maxPrice: number): string[] =>\n  pipe(\n    products,\n    (ps) => ps.filter(p => p.inStock),\n    (ps) => ps.filter(p => p.price <= maxPrice),\n    (ps) => ps.map(p => p.name),\n    (names) => names.sort()\n  )",
    "testCode": "describe('getAffordableInStockProductNames', () => {\n  it('returns products under 100', () => {\n    const result = getAffordableInStockProductNames(100)\n    expect(result).toEqual(['Keyboard'])\n  })\n\n  it('returns products under 500', () => {\n    const result = getAffordableInStockProductNames(500)\n    expect(result).toEqual(['Keyboard', 'Monitor'])\n  })\n\n  it('returns empty array when no products match', () => {\n    const result = getAffordableInStockProductNames(10)\n    expect(result).toEqual([])\n  })\n})"
  },
  {
    "id": "pipe-05",
    "title": "Real World",
    "description": "Learn about real world in fp-ts pipe",
    "category": "Pipe",
    "fileName": "05-real-world.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface ApiResponse {\n  data?: {\n    user?: {\n      profile?: {\n        name: string\n        age: number\n      }\n    }\n  }\n}\n\n// @ts-ignore\nconst extractUserAge = (response: ApiResponse): O.Option<number> => {\n  //TODO:\n  //Use pipe to safely extract the user's age from the nested API response\n  //1. Start with response.data\n  //2. Use O.fromNullable to handle undefined\n  //3. Chain through user, profile, and age\n  //Return None if any part of the chain is undefined\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface ApiResponse {\n  data?: {\n    user?: {\n      profile?: {\n        name: string\n        age: number\n      }\n    }\n  }\n}\n\nexport const extractUserAge = (response: ApiResponse): O.Option<number> =>\n  pipe(\n    response.data,\n    O.fromNullable,\n    O.chain(data => O.fromNullable(data.user)),\n    O.chain(user => O.fromNullable(user.profile)),\n    O.map(profile => profile.age)\n  )",
    "testCode": "describe('extractUserAge', () => {\n  it('extracts age from complete response', () => {\n    const response: ApiResponse = {\n      data: {\n        user: {\n          profile: {\n            name: 'Alice',\n            age: 25\n          }\n        }\n      }\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'Some', value: 25 })\n  })\n\n  it('returns None when data is missing', () => {\n    const response: ApiResponse = {}\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns None when user is missing', () => {\n    const response: ApiResponse = {\n      data: {}\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns None when profile is missing', () => {\n    const response: ApiResponse = {\n      data: {\n        user: {}\n      }\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})"
  },
  {
    "id": "reader-01",
    "title": "Create Reader",
    "description": "Learn about create reader in fp-ts reader",
    "category": "Reader",
    "fileName": "01-create-reader.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface Config {\n  apiUrl: string\n  timeout: number\n}\n\n// @ts-ignore\nconst getApiUrl = (): R.Reader<Config, string> => {\n  //TODO:\n  //Create a Reader that accesses the environment and returns the apiUrl.\n  //Use R.asks() which takes a function that extracts a value from the environment.\n  //For example: R.asks((config: Config) => config.apiUrl)\n}\n\n// @ts-ignore\nconst getTimeout = (): R.Reader<Config, number> => {\n  //TODO:\n  //Create a Reader that accesses the environment and returns the timeout.\n  //Use R.asks() to extract the timeout from the Config.\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\n\ninterface Config {\n  apiUrl: string\n  timeout: number\n}\n\nexport const getApiUrl = (): R.Reader<Config, string> => {\n  return R.asks((config: Config) => config.apiUrl)\n}\n\nexport const getTimeout = (): R.Reader<Config, number> => {\n  return R.asks((config: Config) => config.timeout)\n}",
    "testCode": "describe('Reader basics', () => {\n  const config: Config = {\n    apiUrl: 'https://api.example.com',\n    timeout: 5000,\n  }\n\n  it('getApiUrl extracts apiUrl from config', () => {\n    const result = getApiUrl()(config)\n    expect(result).toBe('https://api.example.com')\n  })\n\n  it('getTimeout extracts timeout from config', () => {\n    const result = getTimeout()(config)\n    expect(result).toBe(5000)\n  })\n\n  it('Reader can be called with different configs', () => {\n    const testConfig: Config = { apiUrl: 'https://test.com', timeout: 1000 }\n    expect(getApiUrl()(testConfig)).toBe('https://test.com')\n    expect(getTimeout()(testConfig)).toBe(1000)\n  })\n})"
  },
  {
    "id": "reader-02",
    "title": "Map",
    "description": "Learn about map in fp-ts reader",
    "category": "Reader",
    "fileName": "02-map.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Config {\n  apiUrl: string\n  version: number\n}\n\n// @ts-ignore\nconst getFullUrl = (endpoint: string): R.Reader<Config, string> => {\n  //TODO:\n  //Create a Reader that:\n  //1. Gets the apiUrl and version from the Config\n  //2. Uses R.asks to access the config\n  //3. Uses pipe and R.map to transform the result\n  //4. Returns a string like: \"{apiUrl}/v{version}/{endpoint}\"\n  //\n  //Example:\n  //pipe(\n  //  R.asks((config: Config) => config.apiUrl),\n  //  R.map(url => `${url}/v${version}/${endpoint}`)\n  //)\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Config {\n  apiUrl: string\n  version: number\n}\n\nexport const getFullUrl = (endpoint: string): R.Reader<Config, string> => {\n  return pipe(\n    R.ask<Config>(),\n    R.map(config => `${config.apiUrl}/v${config.version}/${endpoint}`)\n  )\n}",
    "testCode": "describe('Reader map', () => {\n  const config: Config = {\n    apiUrl: 'https://api.example.com',\n    version: 2,\n  }\n\n  it('builds full URL with endpoint', () => {\n    const result = getFullUrl('users')(config)\n    expect(result).toBe('https://api.example.com/v2/users')\n  })\n\n  it('works with different endpoints', () => {\n    expect(getFullUrl('posts')(config)).toBe('https://api.example.com/v2/posts')\n    expect(getFullUrl('comments')(config)).toBe('https://api.example.com/v2/comments')\n  })\n\n  it('uses version from config', () => {\n    const v1Config = { ...config, version: 1 }\n    expect(getFullUrl('users')(v1Config)).toBe('https://api.example.com/v1/users')\n  })\n})"
  },
  {
    "id": "reader-03",
    "title": "Ask",
    "description": "Learn about ask in fp-ts reader",
    "category": "Reader",
    "fileName": "03-ask.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ninterface AppContext {\n  currentUser: User\n  isAdmin: boolean\n}\n\n// @ts-ignore\nconst getCurrentUserName = (): R.Reader<AppContext, string> => {\n  //TODO:\n  //Use R.ask() to get the entire AppContext, then use R.map to extract the currentUser.name\n  //Hint: pipe(R.ask<AppContext>(), R.map(ctx => ctx.currentUser.name))\n}\n\n// @ts-ignore\nconst getCurrentUserEmail = (): R.Reader<AppContext, string> => {\n  //TODO:\n  //Similar to above, extract the currentUser.email from the context\n}\n\n// @ts-ignore\nconst isCurrentUserAdmin = (): R.Reader<AppContext, boolean> => {\n  //TODO:\n  //Extract the isAdmin flag from the context\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ninterface AppContext {\n  currentUser: User\n  isAdmin: boolean\n}\n\nexport const getCurrentUserName = (): R.Reader<AppContext, string> => {\n  return pipe(\n    R.ask<AppContext>(),\n    R.map(ctx => ctx.currentUser.name)\n  )\n}\n\nexport const getCurrentUserEmail = (): R.Reader<AppContext, string> => {\n  return pipe(\n    R.ask<AppContext>(),\n    R.map(ctx => ctx.currentUser.email)\n  )\n}\n\nexport const isCurrentUserAdmin = (): R.Reader<AppContext, boolean> => {\n  return pipe(\n    R.ask<AppContext>(),\n    R.map(ctx => ctx.isAdmin)\n  )\n}",
    "testCode": "describe('Reader ask', () => {\n  const context: AppContext = {\n    currentUser: {\n      id: 1,\n      name: 'Alice',\n      email: 'alice@example.com',\n    },\n    isAdmin: true,\n  }\n\n  it('gets current user name', () => {\n    expect(getCurrentUserName()(context)).toBe('Alice')\n  })\n\n  it('gets current user email', () => {\n    expect(getCurrentUserEmail()(context)).toBe('alice@example.com')\n  })\n\n  it('checks if user is admin', () => {\n    expect(isCurrentUserAdmin()(context)).toBe(true)\n  })\n\n  it('works with non-admin user', () => {\n    const userContext = { ...context, isAdmin: false }\n    expect(isCurrentUserAdmin()(userContext)).toBe(false)\n  })\n})"
  },
  {
    "id": "reader-04",
    "title": "Chain",
    "description": "Learn about chain in fp-ts reader",
    "category": "Reader",
    "fileName": "04-chain.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Database {\n  host: string\n  port: number\n}\n\ninterface Config {\n  database: Database\n  appName: string\n}\n\n// @ts-ignore\nconst getDatabase = (): R.Reader<Config, Database> => {\n  //TODO:\n  //Create a Reader that extracts the database from Config\n  //Use R.asks((config: Config) => config.database)\n}\n\n// @ts-ignore\nconst getConnectionString = (): R.Reader<Config, string> => {\n  //TODO:\n  //Chain two Readers together:\n  //1. First get the database config using getDatabase()\n  //2. Then transform it to a connection string\n  //\n  //Use pipe with R.chain:\n  //pipe(\n  //  getDatabase(),\n  //  R.chain(db => R.of(`${db.host}:${db.port}`))\n  //)\n  //\n  //Note: R.chain is used to compose Readers that depend on previous Reader results\n}\n\n// @ts-ignore\nconst getFullConnectionString = (): R.Reader<Config, string> => {\n  //TODO:\n  //Chain multiple operations:\n  //1. Get the connection string\n  //2. Also get the appName from config\n  //3. Combine them into: \"appName@host:port\"\n  //\n  //Hint: You can use R.chain multiple times, and use R.ask() inside the chain\n  //to access the config again\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Database {\n  host: string\n  port: number\n}\n\ninterface Config {\n  database: Database\n  appName: string\n}\n\nexport const getDatabase = (): R.Reader<Config, Database> => {\n  return R.asks((config: Config) => config.database)\n}\n\nexport const getConnectionString = (): R.Reader<Config, string> => {\n  return pipe(\n    getDatabase(),\n    R.map(db => `${db.host}:${db.port}`)\n  )\n}\n\nexport const getFullConnectionString = (): R.Reader<Config, string> => {\n  return pipe(\n    getConnectionString(),\n    R.chain(connStr =>\n      pipe(\n        R.asks((config: Config) => config.appName),\n        R.map(appName => `${appName}@${connStr}`)\n      )\n    )\n  )\n}",
    "testCode": "describe('Reader chain', () => {\n  const config: Config = {\n    database: {\n      host: 'localhost',\n      port: 5432,\n    },\n    appName: 'myapp',\n  }\n\n  it('gets database config', () => {\n    const result = getDatabase()(config)\n    expect(result).toEqual({ host: 'localhost', port: 5432 })\n  })\n\n  it('builds connection string', () => {\n    const result = getConnectionString()(config)\n    expect(result).toBe('localhost:5432')\n  })\n\n  it('builds full connection string with app name', () => {\n    const result = getFullConnectionString()(config)\n    expect(result).toBe('myapp@localhost:5432')\n  })\n})"
  },
  {
    "id": "reader-05",
    "title": "Dependency Injection",
    "description": "Learn about dependency injection in fp-ts reader",
    "category": "Reader",
    "fileName": "05-dependency-injection.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Logger {\n  log: (message: string) => void\n}\n\ninterface UserService {\n  getUser: (id: number) => { id: number; name: string } | undefined\n}\n\ninterface Dependencies {\n  logger: Logger\n  userService: UserService\n}\n\n// @ts-ignore\nconst getUserById = (id: number): R.Reader<Dependencies, string> => {\n  //TODO:\n  //Use Reader for dependency injection:\n  //1. Use R.ask() to get the Dependencies\n  //2. Use the userService to get the user\n  //3. Use the logger to log what happened\n  //4. Return a string: either the user name or \"User not found\"\n  //\n  //Example pattern:\n  //pipe(\n  //  R.ask<Dependencies>(),\n  //  R.map(deps => {\n  //    const user = deps.userService.getUser(id)\n  //    if (user) {\n  //      deps.logger.log(`Found user: ${user.name}`)\n  //      return user.name\n  //    } else {\n  //      deps.logger.log(`User ${id} not found`)\n  //      return 'User not found'\n  //    }\n  //  })\n  //)\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Logger {\n  log: (message: string) => void\n}\n\ninterface UserService {\n  getUser: (id: number) => { id: number; name: string } | undefined\n}\n\ninterface Dependencies {\n  logger: Logger\n  userService: UserService\n}\n\nexport const getUserById = (id: number): R.Reader<Dependencies, string> => {\n  return pipe(\n    R.ask<Dependencies>(),\n    R.map(deps => {\n      const user = deps.userService.getUser(id)\n      if (user) {\n        deps.logger.log(`Found user: ${user.name}`)\n        return user.name\n      } else {\n        deps.logger.log(`User ${id} not found`)\n        return 'User not found'\n      }\n    })\n  )\n}",
    "testCode": "describe('Reader dependency injection', () => {\n  const logs: string[] = []\n  const mockLogger: Logger = {\n    log: (msg) => logs.push(msg),\n  }\n\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n  ]\n\n  const mockUserService: UserService = {\n    getUser: (id) => users.find(u => u.id === id),\n  }\n\n  const deps: Dependencies = {\n    logger: mockLogger,\n    userService: mockUserService,\n  }\n\n  beforeEach(() => {\n    logs.length = 0\n  })\n\n  it('finds existing user and logs', () => {\n    const result = getUserById(1)(deps)\n    expect(result).toBe('Alice')\n    expect(logs).toContain('Found user: Alice')\n  })\n\n  it('handles missing user and logs', () => {\n    const result = getUserById(99)(deps)\n    expect(result).toBe('User not found')\n    expect(logs).toContain('User 99 not found')\n  })\n\n  it('works with different user service', () => {\n    const differentService: UserService = {\n      getUser: () => ({ id: 999, name: 'Test User' }),\n    }\n    const testDeps = { ...deps, userService: differentService }\n    const result = getUserById(1)(testDeps)\n    expect(result).toBe('Test User')\n  })\n})"
  },
  {
    "id": "reader-06",
    "title": "Local",
    "description": "Learn about local in fp-ts reader",
    "category": "Reader",
    "fileName": "06-local.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Config {\n  baseUrl: string\n  apiKey: string\n  timeout: number\n}\n\n// @ts-ignore\nconst getUrl = (): R.Reader<Config, string> => {\n  //TODO:\n  //Simple Reader that returns the baseUrl from config\n  //Use R.asks((config: Config) => config.baseUrl)\n}\n\n// @ts-ignore\nconst getUrlWithOverride = (newUrl: string): R.Reader<Config, string> => {\n  //TODO:\n  //Use R.local to temporarily modify the config environment:\n  //1. R.local takes two arguments:\n  //    - A function that modifies the environment: (config: Config) => Config\n  //    - The Reader to run with the modified environment\n  //2. Override the baseUrl in the config\n  //3. Run getUrl() with the modified config\n  //\n  //Example:\n  //pipe(\n  //  getUrl(),\n  //  R.local((config: Config) => ({ ...config, baseUrl: newUrl }))\n  //)\n}\n\n// @ts-ignore\nconst getUrlWithTimeout = (newTimeout: number): R.Reader<Config, { url: string; timeout: number }> => {\n  //TODO:\n  //Use R.local to override the timeout in the config:\n  //1. Modify the environment to change the timeout\n  //2. Return both url and timeout from the modified config\n  //\n  //Hint: Use R.ask() to get the modified config, then map to extract both values\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Config {\n  baseUrl: string\n  apiKey: string\n  timeout: number\n}\n\nexport const getUrl = (): R.Reader<Config, string> => {\n  return R.asks((config: Config) => config.baseUrl)\n}\n\nexport const getUrlWithOverride = (newUrl: string): R.Reader<Config, string> => {\n  return pipe(\n    getUrl(),\n    R.local((config: Config) => ({ ...config, baseUrl: newUrl }))\n  )\n}\n\nexport const getUrlWithTimeout = (newTimeout: number): R.Reader<Config, { url: string; timeout: number }> => {\n  return pipe(\n    R.ask<Config>(),\n    R.local((config: Config) => ({ ...config, timeout: newTimeout })),\n    R.map(config => ({ url: config.baseUrl, timeout: config.timeout }))\n  )\n}",
    "testCode": "describe('Reader local', () => {\n  const config: Config = {\n    baseUrl: 'https://api.example.com',\n    apiKey: 'secret123',\n    timeout: 5000,\n  }\n\n  it('gets base URL from config', () => {\n    expect(getUrl()(config)).toBe('https://api.example.com')\n  })\n\n  it('overrides URL locally without affecting original config', () => {\n    const result = getUrlWithOverride('https://test.com')(config)\n    expect(result).toBe('https://test.com')\n    // Original config unchanged\n    expect(getUrl()(config)).toBe('https://api.example.com')\n  })\n\n  it('overrides timeout locally', () => {\n    const result = getUrlWithTimeout(1000)(config)\n    expect(result).toEqual({\n      url: 'https://api.example.com',\n      timeout: 1000,\n    })\n  })\n\n  it('multiple local overrides work independently', () => {\n    expect(getUrlWithOverride('https://dev.com')(config)).toBe('https://dev.com')\n    expect(getUrlWithOverride('https://staging.com')(config)).toBe('https://staging.com')\n  })\n})"
  },
  {
    "id": "reader-07",
    "title": "Real World Config",
    "description": "Learn about real world config in fp-ts reader",
    "category": "Reader",
    "fileName": "07-real-world-config.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface DatabaseConfig {\n  host: string\n  port: number\n  username: string\n  password: string\n}\n\ninterface ApiConfig {\n  baseUrl: string\n  apiKey: string\n  timeout: number\n}\n\ninterface AppConfig {\n  database: DatabaseConfig\n  api: ApiConfig\n  env: 'development' | 'production' | 'test'\n}\n\n// @ts-ignore\nconst getDatabaseUrl = (): R.Reader<AppConfig, string> => {\n  //TODO:\n  //Build a database connection URL from the database config\n  //Format: \"postgresql://{username}:{password}@{host}:{port}\"\n  //\n  //Use pipe with R.asks to extract database config, then R.map to build the string\n}\n\n// @ts-ignore\nconst getApiEndpoint = (path: string): R.Reader<AppConfig, string> => {\n  //TODO:\n  //Build a full API endpoint URL\n  //Format: \"{baseUrl}/{path}?key={apiKey}\"\n  //\n  //Extract the api config and build the endpoint string\n}\n\n// @ts-ignore\nconst getConfigSummary = (): R.Reader<AppConfig, { env: string; dbHost: string; apiUrl: string }> => {\n  //TODO:\n  //Create a summary object combining multiple config values:\n  //1. Get the environment (env)\n  //2. Get the database host\n  //3. Get the API baseUrl\n  //\n  //Return an object with: { env, dbHost, apiUrl }\n  //\n  //Hint: Use R.ask() to get the entire config, then map to extract the needed fields\n}\n\n// @ts-ignore\nconst isProduction = (): R.Reader<AppConfig, boolean> => {\n  //TODO:\n  //Simple Reader that checks if env === 'production'\n  //Use R.asks to extract and check the env field\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface DatabaseConfig {\n  host: string\n  port: number\n  username: string\n  password: string\n}\n\ninterface ApiConfig {\n  baseUrl: string\n  apiKey: string\n  timeout: number\n}\n\ninterface AppConfig {\n  database: DatabaseConfig\n  api: ApiConfig\n  env: 'development' | 'production' | 'test'\n}\n\nexport const getDatabaseUrl = (): R.Reader<AppConfig, string> => {\n  return pipe(\n    R.asks((config: AppConfig) => config.database),\n    R.map(db => `postgresql://${db.username}:${db.password}@${db.host}:${db.port}`)\n  )\n}\n\nexport const getApiEndpoint = (path: string): R.Reader<AppConfig, string> => {\n  return pipe(\n    R.asks((config: AppConfig) => config.api),\n    R.map(api => `${api.baseUrl}/${path}?key=${api.apiKey}`)\n  )\n}\n\nexport const getConfigSummary = (): R.Reader<AppConfig, { env: string; dbHost: string; apiUrl: string }> => {\n  return pipe(\n    R.ask<AppConfig>(),\n    R.map(config => ({\n      env: config.env,\n      dbHost: config.database.host,\n      apiUrl: config.api.baseUrl,\n    }))\n  )\n}\n\nexport const isProduction = (): R.Reader<AppConfig, boolean> => {\n  return R.asks((config: AppConfig) => config.env === 'production')\n}",
    "testCode": "describe('Real-world configuration', () => {\n  const config: AppConfig = {\n    database: {\n      host: 'db.example.com',\n      port: 5432,\n      username: 'admin',\n      password: 'secret123',\n    },\n    api: {\n      baseUrl: 'https://api.example.com',\n      apiKey: 'abc123',\n      timeout: 5000,\n    },\n    env: 'production',\n  }\n\n  it('builds database connection URL', () => {\n    const result = getDatabaseUrl()(config)\n    expect(result).toBe('postgresql://admin:secret123@db.example.com:5432')\n  })\n\n  it('builds API endpoint with path', () => {\n    const result = getApiEndpoint('users')(config)\n    expect(result).toBe('https://api.example.com/users?key=abc123')\n  })\n\n  it('creates config summary', () => {\n    const result = getConfigSummary()(config)\n    expect(result).toEqual({\n      env: 'production',\n      dbHost: 'db.example.com',\n      apiUrl: 'https://api.example.com',\n    })\n  })\n\n  it('checks if production environment', () => {\n    expect(isProduction()(config)).toBe(true)\n\n    const devConfig = { ...config, env: 'development' as const }\n    expect(isProduction()(devConfig)).toBe(false)\n  })\n\n  it('works with different configurations', () => {\n    const testConfig: AppConfig = {\n      ...config,\n      database: { ...config.database, host: 'localhost', port: 5433 },\n      env: 'test',\n    }\n    expect(getDatabaseUrl()(testConfig)).toBe('postgresql://admin:secret123@localhost:5433')\n    expect(isProduction()(testConfig)).toBe(false)\n  })\n})"
  },
  {
    "id": "reader-08",
    "title": "Reader Pipeline",
    "description": "Learn about reader pipeline in fp-ts reader",
    "category": "Reader",
    "fileName": "08-reader-pipeline.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Logger {\n  log: (msg: string) => void\n}\n\ninterface Cache {\n  get: (key: string) => string | undefined\n  set: (key: string, value: string) => void\n}\n\ninterface HttpClient {\n  fetch: (url: string) => Promise<string>\n}\n\ninterface AppDependencies {\n  logger: Logger\n  cache: Cache\n  httpClient: HttpClient\n  baseUrl: string\n}\n\n// @ts-ignore\nconst logMessage = (message: string): R.Reader<AppDependencies, void> => {\n  //TODO:\n  //Create a Reader that uses the logger to log a message\n  //Use pipe with R.ask(), then R.map to call deps.logger.log(message)\n}\n\n// @ts-ignore\nconst getCachedValue = (key: string): R.Reader<AppDependencies, string | undefined> => {\n  //TODO:\n  //Create a Reader that gets a value from the cache\n  //Use pipe with R.ask(), then R.map to call deps.cache.get(key)\n}\n\n// @ts-ignore\nconst setCachedValue = (key: string, value: string): R.Reader<AppDependencies, void> => {\n  //TODO:\n  //Create a Reader that sets a value in the cache\n  //Use pipe with R.ask(), then R.map to call deps.cache.set(key, value)\n}\n\n// @ts-ignore\nconst buildUrl = (endpoint: string): R.Reader<AppDependencies, string> => {\n  //TODO:\n  //Create a Reader that builds a full URL from baseUrl + endpoint\n  //Use R.asks to extract baseUrl and return `${baseUrl}/${endpoint}`\n}\n\n// @ts-ignore\nconst fetchWithCache = (endpoint: string): R.Reader<AppDependencies, string> => {\n  //TODO:\n  //Create a complex Reader pipeline that:\n  //1. Logs \"Fetching {endpoint}\"\n  //2. Checks the cache for the endpoint\n  //3. If cached, logs \"Cache hit\" and returns cached value\n  //4. If not cached, logs \"Cache miss\", builds URL, fetches data, caches it, and returns it\n  //\n  //This is advanced! You'll need to:\n  //- Use R.chain to sequence operations that depend on previous results\n  //- Use R.ask() to access dependencies multiple times\n  //- Handle the cache hit/miss logic\n  //\n  //Hint structure:\n  //pipe(\n  //  logMessage(`Fetching ${endpoint}`),\n  //  R.chain(() => getCachedValue(endpoint)),\n  //  R.chain(cached =>\n  //    cached\n  //      ? pipe(logMessage('Cache hit'), R.map(() => cached))\n  //      : pipe(\n  //          logMessage('Cache miss'),\n  //          R.chain(() => buildUrl(endpoint)),\n  //          R.chain(url => R.asks((deps: AppDependencies) => {\n  //            // Note: In real code, you'd handle the Promise properly\n  //            // For this exercise, we'll use a sync version\n  //            const data = 'mock data for ' + url\n  //            return data\n  //          })),\n  //          R.chain(data => pipe(\n  //            setCachedValue(endpoint, data),\n  //            R.map(() => data)\n  //          ))\n  //        )\n  //  )\n  //)\n}",
    "solutionCode": "import * as R from 'fp-ts/Reader'\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface Logger {\n  log: (msg: string) => void\n}\n\ninterface Cache {\n  get: (key: string) => string | undefined\n  set: (key: string, value: string) => void\n}\n\ninterface HttpClient {\n  fetch: (url: string) => Promise<string>\n}\n\ninterface AppDependencies {\n  logger: Logger\n  cache: Cache\n  httpClient: HttpClient\n  baseUrl: string\n}\n\nexport const logMessage = (message: string): R.Reader<AppDependencies, void> => {\n  return pipe(\n    R.ask<AppDependencies>(),\n    R.map(deps => deps.logger.log(message))\n  )\n}\n\nexport const getCachedValue = (key: string): R.Reader<AppDependencies, string | undefined> => {\n  return pipe(\n    R.ask<AppDependencies>(),\n    R.map(deps => deps.cache.get(key))\n  )\n}\n\nexport const setCachedValue = (key: string, value: string): R.Reader<AppDependencies, void> => {\n  return pipe(\n    R.ask<AppDependencies>(),\n    R.map(deps => deps.cache.set(key, value))\n  )\n}\n\nexport const buildUrl = (endpoint: string): R.Reader<AppDependencies, string> => {\n  return R.asks((deps: AppDependencies) => `${deps.baseUrl}/${endpoint}`)\n}\n\nexport const fetchWithCache = (endpoint: string): R.Reader<AppDependencies, string> => {\n  return pipe(\n    logMessage(`Fetching ${endpoint}`),\n    R.chain(() => getCachedValue(endpoint)),\n    R.chain(cached =>\n      cached\n        ? pipe(\n            logMessage('Cache hit'),\n            R.map(() => cached)\n          )\n        : pipe(\n            logMessage('Cache miss'),\n            R.chain(() => buildUrl(endpoint)),\n            R.map(url => `mock data for ${url}`),\n            R.chain(data =>\n              pipe(\n                setCachedValue(endpoint, data),\n                R.map(() => data)\n              )\n            )\n          )\n    )\n  )\n}",
    "testCode": "describe('Reader pipeline', () => {\n  const logs: string[] = []\n  const cacheStore = new Map<string, string>()\n\n  const deps: AppDependencies = {\n    logger: {\n      log: (msg) => logs.push(msg),\n    },\n    cache: {\n      get: (key) => cacheStore.get(key),\n      set: (key, value) => cacheStore.set(key, value),\n    },\n    httpClient: {\n      fetch: async (url) => `data from ${url}`,\n    },\n    baseUrl: 'https://api.example.com',\n  }\n\n  beforeEach(() => {\n    logs.length = 0\n    cacheStore.clear()\n  })\n\n  it('logs a message', () => {\n    logMessage('test message')(deps)\n    expect(logs).toContain('test message')\n  })\n\n  it('gets cached value', () => {\n    cacheStore.set('key1', 'value1')\n    const result = getCachedValue('key1')(deps)\n    expect(result).toBe('value1')\n  })\n\n  it('sets cached value', () => {\n    setCachedValue('key2', 'value2')(deps)\n    expect(cacheStore.get('key2')).toBe('value2')\n  })\n\n  it('builds URL', () => {\n    const result = buildUrl('users')(deps)\n    expect(result).toBe('https://api.example.com/users')\n  })\n\n  it('fetches with cache miss', () => {\n    const result = fetchWithCache('users')(deps)\n    expect(logs).toContain('Fetching users')\n    expect(logs).toContain('Cache miss')\n    expect(result).toContain('api.example.com/users')\n    expect(cacheStore.get('users')).toBeDefined()\n  })\n\n  it('fetches with cache hit', () => {\n    cacheStore.set('posts', 'cached posts data')\n    const result = fetchWithCache('posts')(deps)\n    expect(logs).toContain('Fetching posts')\n    expect(logs).toContain('Cache hit')\n    expect(result).toBe('cached posts data')\n  })\n})"
  },
  {
    "id": "record-01",
    "title": "Map",
    "description": "Learn about map in fp-ts record",
    "category": "Record",
    "fileName": "01-map.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst doubleValues = (record: Record<string, number>): Record<string, number> => {\n  //TODO: Use Record.map to double all values in the record\n  //HINT: Import * as R from 'fp-ts/Record'\n}\n\n// @ts-ignore\nconst uppercaseValues = (record: Record<string, string>): Record<string, string> => {\n  //TODO: Use Record.map to uppercase all string values\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const doubleValues = (record: Record<string, number>): Record<string, number> =>\n  pipe(\n    record,\n    R.map((n) => n * 2)\n  )\n\nexport const uppercaseValues = (record: Record<string, string>): Record<string, string> =>\n  pipe(\n    record,\n    R.map((s) => s.toUpperCase())\n  )",
    "testCode": "describe('Record map operations', () => {\n  it('doubles all values', () => {\n    const input = { a: 1, b: 2, c: 3 }\n    const result = doubleValues(input)\n    expect(result).toEqual({ a: 2, b: 4, c: 6 })\n  })\n\n  it('handles empty record', () => {\n    const result = doubleValues({})\n    expect(result).toEqual({})\n  })\n\n  it('uppercases all values', () => {\n    const input = { name: 'alice', city: 'paris' }\n    const result = uppercaseValues(input)\n    expect(result).toEqual({ name: 'ALICE', city: 'PARIS' })\n  })\n})"
  },
  {
    "id": "record-02",
    "title": "Filter",
    "description": "Learn about filter in fp-ts record",
    "category": "Record",
    "fileName": "02-filter.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst filterPositive = (record: Record<string, number>): Record<string, number> => {\n  //TODO: Use Record.filter to keep only positive numbers\n}\n\n// @ts-ignore\nconst filterByLength = (record: Record<string, string>, minLength: number): Record<string, string> => {\n  //TODO: Use Record.filter to keep only strings with length >= minLength\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const filterPositive = (record: Record<string, number>): Record<string, number> =>\n  pipe(\n    record,\n    R.filter((n) => n > 0)\n  )\n\nexport const filterByLength = (record: Record<string, string>, minLength: number): Record<string, string> =>\n  pipe(\n    record,\n    R.filter((s) => s.length >= minLength)\n  )",
    "testCode": "describe('Record filter operations', () => {\n  it('filters positive numbers', () => {\n    const input = { a: 5, b: -2, c: 10, d: -7, e: 3 }\n    const result = filterPositive(input)\n    expect(result).toEqual({ a: 5, c: 10, e: 3 })\n  })\n\n  it('returns empty record when no matches', () => {\n    const input = { a: -1, b: -2 }\n    const result = filterPositive(input)\n    expect(result).toEqual({})\n  })\n\n  it('filters by string length', () => {\n    const input = { a: 'hi', b: 'hello', c: 'hey', d: 'goodbye' }\n    const result = filterByLength(input, 5)\n    expect(result).toEqual({ b: 'hello', d: 'goodbye' })\n  })\n})"
  },
  {
    "id": "record-03",
    "title": "Collect",
    "description": "Learn about collect in fp-ts record",
    "category": "Record",
    "fileName": "03-collect.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst toArray = (record: Record<string, number>): Array<{ key: string; value: number }> => {\n  //TODO: Use Record.collect to convert record to array of key-value pairs\n  //HINT: collect takes a function (key, value) => result\n}\n\n// @ts-ignore\nconst sumValues = (record: Record<string, number>): number => {\n  //TODO: Use Record.collect to get all values, then sum them\n  //HINT: Collect values into an array, then reduce\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const toArray = (record: Record<string, number>): Array<{ key: string; value: number }> =>\n  pipe(\n    record,\n    R.collect((key, value) => ({ key, value }))\n  )\n\nexport const sumValues = (record: Record<string, number>): number =>\n  pipe(\n    record,\n    R.collect((_, value) => value),\n    A.reduce(0, (acc, n) => acc + n)\n  )",
    "testCode": "describe('Record collect operations', () => {\n  it('converts record to array', () => {\n    const input = { a: 1, b: 2, c: 3 }\n    const result = toArray(input)\n    expect(result).toEqual([\n      { key: 'a', value: 1 },\n      { key: 'b', value: 2 },\n      { key: 'c', value: 3 },\n    ])\n  })\n\n  it('sums all values', () => {\n    const input = { x: 10, y: 20, z: 30 }\n    const result = sumValues(input)\n    expect(result).toBe(60)\n  })\n\n  it('handles empty record', () => {\n    const result = sumValues({})\n    expect(result).toBe(0)\n  })\n})"
  },
  {
    "id": "record-04",
    "title": "Lookup",
    "description": "Learn about lookup in fp-ts record",
    "category": "Record",
    "fileName": "04-lookup.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getValue = (record: Record<string, number>, key: string): O.Option<number> => {\n  //TODO: Use Record.lookup to safely get a value by key\n  //HINT: Returns Option because key might not exist\n}\n\n// @ts-ignore\nconst getValueWithDefault = (record: Record<string, number>, key: string, defaultValue: number): number => {\n  //TODO: Lookup the key and return the value, or defaultValue if not found\n  //HINT: Use pipe with O.getOrElse\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const getValue = (record: Record<string, number>, key: string): O.Option<number> =>\n  R.lookup(key)(record)\n\nexport const getValueWithDefault = (record: Record<string, number>, key: string, defaultValue: number): number =>\n  pipe(\n    R.lookup(key)(record),\n    O.getOrElse(() => defaultValue)\n  )",
    "testCode": "describe('Record lookup operations', () => {\n  it('looks up existing key', () => {\n    const record = { a: 10, b: 20, c: 30 }\n    const result = getValue(record, 'b')\n    expect(O.isSome(result)).toBe(true)\n    expect(result).toEqual(O.some(20))\n  })\n\n  it('returns None for missing key', () => {\n    const record = { a: 10 }\n    const result = getValue(record, 'z')\n    expect(O.isNone(result)).toBe(true)\n  })\n\n  it('gets value with default', () => {\n    const record = { a: 10, b: 20 }\n    expect(getValueWithDefault(record, 'a', 0)).toBe(10)\n    expect(getValueWithDefault(record, 'z', 999)).toBe(999)\n  })\n})"
  },
  {
    "id": "record-05",
    "title": "Modify",
    "description": "Learn about modify in fp-ts record",
    "category": "Record",
    "fileName": "05-modify.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst incrementKey = (record: Record<string, number>, key: string): Record<string, number> => {\n  //TODO: Use Record.modifyAt to increment the value at the given key\n  //HINT: Returns Option<Record> because key might not exist\n}\n\n// @ts-ignore\nconst updateAt = (record: Record<string, string>, key: string, newValue: string): Record<string, string> => {\n  //TODO: Use Record.updateAt to set a new value at the key\n  //HINT: Similar to modifyAt but replaces with a fixed value\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const incrementKey = (record: Record<string, number>, key: string): Record<string, number> =>\n  pipe(\n    record,\n    R.modifyAt(key, (n) => n + 1),\n    O.getOrElse(() => record)\n  )\n\nexport const updateAt = (record: Record<string, string>, key: string, newValue: string): Record<string, string> =>\n  pipe(\n    record,\n    R.updateAt(key, newValue),\n    O.getOrElse(() => record)\n  )",
    "testCode": "describe('Record modify operations', () => {\n  it('modifies existing key', () => {\n    const record = { a: 10, b: 20, c: 30 }\n    const result = incrementKey(record, 'b')\n    expect(result).toEqual({ a: 10, b: 21, c: 30 })\n  })\n\n  it('handles missing key', () => {\n    const record = { a: 10 }\n    const result = incrementKey(record, 'z')\n    expect(result).toEqual({ a: 10 })\n  })\n\n  it('updates value at key', () => {\n    const record = { name: 'Alice', city: 'Paris' }\n    const result = updateAt(record, 'city', 'London')\n    expect(result).toEqual({ name: 'Alice', city: 'London' })\n  })\n})"
  },
  {
    "id": "record-06",
    "title": "Keys Values",
    "description": "Learn about keys values in fp-ts record",
    "category": "Record",
    "fileName": "06-keys-values.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getKeys = (record: Record<string, any>): string[] => {\n  //TODO: Use Record.keys to get all keys as an array\n}\n\n// @ts-ignore\nconst hasKey = (record: Record<string, any>, key: string): boolean => {\n  //TODO: Use Record.has to check if a key exists\n}\n\n// @ts-ignore\nconst isEmpty = (record: Record<string, any>): boolean => {\n  //TODO: Use Record.isEmpty to check if record has no keys\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport { describe, it, expect } from 'vitest'\n\nexport const getKeys = (record: Record<string, any>): string[] =>\n  R.keys(record)\n\nexport const hasKey = (record: Record<string, any>, key: string): boolean =>\n  R.has(key, record)\n\nexport const isEmpty = (record: Record<string, any>): boolean =>\n  R.isEmpty(record)",
    "testCode": "describe('Record keys and values operations', () => {\n  it('gets all keys', () => {\n    const record = { a: 1, b: 2, c: 3 }\n    const result = getKeys(record)\n    expect(result).toEqual(['a', 'b', 'c'])\n  })\n\n  it('checks if key exists', () => {\n    const record = { name: 'Alice', age: 25 }\n    expect(hasKey(record, 'name')).toBe(true)\n    expect(hasKey(record, 'city')).toBe(false)\n  })\n\n  it('checks if record is empty', () => {\n    expect(isEmpty({})).toBe(true)\n    expect(isEmpty({ a: 1 })).toBe(false)\n  })\n})"
  },
  {
    "id": "record-07",
    "title": "Merge",
    "description": "Learn about merge in fp-ts record",
    "category": "Record",
    "fileName": "07-merge.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst mergeConfigs = (defaults: Record<string, any>, overrides: Record<string, any>): Record<string, any> => {\n  //TODO: Use Record union to merge two configs (overrides take precedence)\n  //HINT: Second argument to union wins on conflicts\n}\n\n// @ts-ignore\nconst combineScores = (scores1: Record<string, number>, scores2: Record<string, number>): Record<string, number> => {\n  //TODO: Merge two score records, summing values for duplicate keys\n  //HINT: Use Record.union with a Semigroup that adds numbers\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\nexport const mergeConfigs = (defaults: Record<string, any>, overrides: Record<string, any>): Record<string, any> => ({\n  ...defaults,\n  ...overrides,\n})\n\nexport const combineScores = (scores1: Record<string, number>, scores2: Record<string, number>): Record<string, number> =>\n  R.union(N.SemigroupSum)(scores2)(scores1)",
    "testCode": "describe('Record merge operations', () => {\n  it('merges configs with overrides', () => {\n    const defaults = { theme: 'light', fontSize: 14, debug: false }\n    const overrides = { theme: 'dark', debug: true }\n    const result = mergeConfigs(defaults, overrides)\n    expect(result).toEqual({ theme: 'dark', fontSize: 14, debug: true })\n  })\n\n  it('combines scores by summing', () => {\n    const scores1 = { alice: 10, bob: 20 }\n    const scores2 = { bob: 15, charlie: 25 }\n    const result = combineScores(scores1, scores2)\n    expect(result).toEqual({ alice: 10, bob: 35, charlie: 25 })\n  })\n})"
  },
  {
    "id": "record-08",
    "title": "Pipeline",
    "description": "Learn about pipeline in fp-ts record",
    "category": "Record",
    "fileName": "08-pipeline.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ntype UserData = {\n  name: string\n  email: string\n  age: number\n  active: boolean\n}\n\n// @ts-ignore\nconst processUserData = (users: Record<string, UserData>): Record<string, string> => {\n  //TODO: Create a pipeline that:\n  // 1. Filters for active users only\n  // 2. Filters for users 18 or older\n  // 3. Maps to format: \"Name (email)\"\n  //HINT: Chain filter, filter, map operations\n}\n\n// @ts-ignore\nconst aggregateByCategory = (\n  items: Record<string, { category: string; value: number }>\n): Record<string, number> => {\n  //TODO: Group items by category and sum their values\n  // 1. Collect items into array\n  // 2. Group by category (manually create new record)\n  // 3. Sum values for each category\n}",
    "solutionCode": "import * as R from 'fp-ts/Record'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype UserData = {\n  name: string\n  email: string\n  age: number\n  active: boolean\n}\n\nexport const processUserData = (users: Record<string, UserData>): Record<string, string> =>\n  pipe(\n    users,\n    R.filter((user) => user.active),\n    R.filter((user) => user.age >= 18),\n    R.map((user) => `${user.name} (${user.email})`)\n  )\n\nexport const aggregateByCategory = (\n  items: Record<string, { category: string; value: number }>\n): Record<string, number> =>\n  pipe(\n    items,\n    R.collect((_, item) => item),\n    A.reduce({} as Record<string, number>, (acc, item) => ({\n      ...acc,\n      [item.category]: (acc[item.category] || 0) + item.value,\n    }))\n  )",
    "testCode": "describe('Record real-world pipeline', () => {\n  it('processes user data', () => {\n    const users: Record<string, UserData> = {\n      u1: { name: 'Alice', email: 'alice@example.com', age: 25, active: true },\n      u2: { name: 'Bob', email: 'bob@example.com', age: 17, active: true },\n      u3: { name: 'Charlie', email: 'charlie@example.com', age: 30, active: false },\n      u4: { name: 'David', email: 'david@example.com', age: 22, active: true },\n    }\n\n    const result = processUserData(users)\n    expect(result).toEqual({\n      u1: 'Alice (alice@example.com)',\n      u4: 'David (david@example.com)',\n    })\n  })\n\n  it('aggregates by category', () => {\n    const items = {\n      item1: { category: 'food', value: 10 },\n      item2: { category: 'tech', value: 50 },\n      item3: { category: 'food', value: 15 },\n      item4: { category: 'tech', value: 30 },\n      item5: { category: 'books', value: 20 },\n    }\n\n    const result = aggregateByCategory(items)\n    expect(result).toEqual({\n      food: 25,\n      tech: 80,\n      books: 20,\n    })\n  })\n})"
  },
  {
    "id": "semigroup-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts semigroup",
    "category": "Semigroup",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst combineStrings = (s1: string, s2: string): string => {\n  //TODO: Use Semigroup to concatenate two strings\n  //HINT: S.concatAll takes a semigroup and an array\n}\n\n// @ts-ignore\nconst combineNumbers = (numbers: number[]): number => {\n  //TODO: Use N.SemigroupSum to sum all numbers\n  //HINT: S.concatAll(N.SemigroupSum)(numbers)\n}",
    "solutionCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport * as Str from 'fp-ts/string'\nimport { describe, it, expect } from 'vitest'\n\nconst StringWithSpace: S.Semigroup<string> = {\n  concat: (x, y) => `${x} ${y}`,\n}\n\nexport const combineStrings = (s1: string, s2: string): string =>\n  StringWithSpace.concat(s1, s2)\n\nexport const combineNumbers = (numbers: number[]): number =>\n  S.concatAll(N.SemigroupSum)(0)(numbers)",
    "testCode": "describe('Semigroup basics', () => {\n  it('combines strings with space', () => {\n    const result = combineStrings('Hello', 'World')\n    expect(result).toBe('Hello World')\n  })\n\n  it('sums numbers using SemigroupSum', () => {\n    const result = combineNumbers([1, 2, 3, 4, 5])\n    expect(result).toBe(15)\n  })\n\n  it('handles single number', () => {\n    const result = combineNumbers([42])\n    expect(result).toBe(42)\n  })\n})"
  },
  {
    "id": "semigroup-02",
    "title": "Struct",
    "description": "Learn about struct in fp-ts semigroup",
    "category": "Semigroup",
    "fileName": "02-struct.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype Point = {\n  x: number\n  y: number\n}\n\n// @ts-ignore\nconst combinePoints = (p1: Point, p2: Point): Point => {\n  //TODO: Create a Semigroup for Points that adds x and y coordinates\n  //HINT: Use S.struct to combine semigroups for each field\n}\n\ntype Stats = {\n  count: number\n  total: number\n}\n\n// @ts-ignore\nconst combineStats = (stats: Stats[]): Stats => {\n  //TODO: Combine multiple Stats by summing both count and total\n  //HINT: Use S.struct with N.SemigroupSum, then S.concatAll\n}",
    "solutionCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype Point = {\n  x: number\n  y: number\n}\n\nconst PointSemigroup: S.Semigroup<Point> = S.struct({\n  x: N.SemigroupSum,\n  y: N.SemigroupSum,\n})\n\nexport const combinePoints = (p1: Point, p2: Point): Point =>\n  PointSemigroup.concat(p1, p2)\n\ntype Stats = {\n  count: number\n  total: number\n}\n\nconst StatsSemigroup: S.Semigroup<Stats> = S.struct({\n  count: N.SemigroupSum,\n  total: N.SemigroupSum,\n})\n\nexport const combineStats = (stats: Stats[]): Stats =>\n  S.concatAll(StatsSemigroup)({ count: 0, total: 0 })(stats)",
    "testCode": "describe('Semigroup struct', () => {\n  it('combines points by adding coordinates', () => {\n    const p1 = { x: 1, y: 2 }\n    const p2 = { x: 3, y: 4 }\n    const result = combinePoints(p1, p2)\n    expect(result).toEqual({ x: 4, y: 6 })\n  })\n\n  it('combines multiple stats', () => {\n    const stats = [\n      { count: 5, total: 100 },\n      { count: 3, total: 50 },\n      { count: 2, total: 30 },\n    ]\n    const result = combineStats(stats)\n    expect(result).toEqual({ count: 10, total: 180 })\n  })\n\n  it('handles single stat', () => {\n    const result = combineStats([{ count: 7, total: 42 }])\n    expect(result).toEqual({ count: 7, total: 42 })\n  })\n})"
  },
  {
    "id": "semigroup-03",
    "title": "First Last",
    "description": "Learn about first last in fp-ts semigroup",
    "category": "Semigroup",
    "fileName": "03-first-last.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as S from 'fp-ts/Semigroup'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getFirstValue = <T>(values: T[]): T => {\n  //TODO: Use S.first to always take the first value when combining\n  //HINT: S.first creates a semigroup that keeps the first element\n}\n\n// @ts-ignore\nconst getLastValue = <T>(values: T[]): T => {\n  //TODO: Use S.last to always take the last value when combining\n  //HINT: S.last creates a semigroup that keeps the last element\n}\n\n// @ts-ignore\nconst getMinNumber = (numbers: number[]): number => {\n  //TODO: Create a semigroup that keeps the minimum number\n  //HINT: Use S.min from fp-ts/Ord with N.Ord\n}",
    "solutionCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\nexport const getFirstValue = <T>(values: T[]): T =>\n  S.concatAll(S.first<T>())(values[0])(values)\n\nexport const getLastValue = <T>(values: T[]): T =>\n  S.concatAll(S.last<T>())(values[0])(values)\n\nexport const getMinNumber = (numbers: number[]): number =>\n  S.concatAll(S.min(N.Ord))(numbers[0])(numbers)",
    "testCode": "describe('Semigroup first, last, min', () => {\n  it('gets first value', () => {\n    const result = getFirstValue([1, 2, 3, 4, 5])\n    expect(result).toBe(1)\n  })\n\n  it('gets last value', () => {\n    const result = getLastValue(['a', 'b', 'c', 'd'])\n    expect(result).toBe('d')\n  })\n\n  it('gets minimum number', () => {\n    const result = getMinNumber([5, 2, 8, 1, 9])\n    expect(result).toBe(1)\n  })\n\n  it('handles single value', () => {\n    expect(getFirstValue([42])).toBe(42)\n    expect(getLastValue([42])).toBe(42)\n    expect(getMinNumber([42])).toBe(42)\n  })\n})"
  },
  {
    "id": "semigroup-04",
    "title": "Practical",
    "description": "Learn about practical in fp-ts semigroup",
    "category": "Semigroup",
    "fileName": "04-practical.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype UserPreferences = {\n  theme: string\n  fontSize: number\n  notifications: boolean\n}\n\n// @ts-ignore\nconst mergePreferences = (prefs: UserPreferences[]): UserPreferences => {\n  //TODO: Merge user preferences where later values override earlier ones\n  //HINT: Use S.struct with S.last for theme/notifications, N.SemigroupSum for fontSize\n}\n\ntype Analytics = {\n  pageViews: number\n  uniqueVisitors: number\n  avgTimeOnSite: number\n}\n\n// @ts-ignore\nconst combineAnalytics = (analytics: Analytics[]): Analytics => {\n  //TODO: Combine analytics by:\n  // - Sum pageViews and uniqueVisitors\n  // - Average avgTimeOnSite\n  //HINT: For average, you'll need a custom semigroup that tracks count\n}",
    "solutionCode": "import * as S from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\nimport { describe, it, expect } from 'vitest'\n\ntype UserPreferences = {\n  theme: string\n  fontSize: number\n  notifications: boolean\n}\n\nconst UserPreferencesSemigroup: S.Semigroup<UserPreferences> = S.struct({\n  theme: S.last<string>(),\n  fontSize: N.SemigroupSum,\n  notifications: S.last<boolean>(),\n})\n\nexport const mergePreferences = (prefs: UserPreferences[]): UserPreferences =>\n  S.concatAll(UserPreferencesSemigroup)({\n    theme: 'light',\n    fontSize: 0,\n    notifications: false,\n  })(prefs)\n\ntype Analytics = {\n  pageViews: number\n  uniqueVisitors: number\n  avgTimeOnSite: number\n}\n\ntype AnalyticsWithCount = Analytics & { count: number }\n\nconst AnalyticsWithCountSemigroup: S.Semigroup<AnalyticsWithCount> = S.struct({\n  pageViews: N.SemigroupSum,\n  uniqueVisitors: N.SemigroupSum,\n  avgTimeOnSite: N.SemigroupSum,\n  count: N.SemigroupSum,\n})\n\nexport const combineAnalytics = (analytics: Analytics[]): Analytics => {\n  const withCount = analytics.map((a) => ({ ...a, count: 1 }))\n  const combined = S.concatAll(AnalyticsWithCountSemigroup)({\n    pageViews: 0,\n    uniqueVisitors: 0,\n    avgTimeOnSite: 0,\n    count: 0,\n  })(withCount)\n\n  return {\n    pageViews: combined.pageViews,\n    uniqueVisitors: combined.uniqueVisitors,\n    avgTimeOnSite: Math.round(combined.avgTimeOnSite / combined.count),\n  }\n}",
    "testCode": "describe('Semigroup practical examples', () => {\n  it('merges user preferences with last value winning', () => {\n    const prefs = [\n      { theme: 'light', fontSize: 14, notifications: false },\n      { theme: 'dark', fontSize: 2, notifications: true },\n      { theme: 'light', fontSize: 0, notifications: false },\n    ]\n    const result = mergePreferences(prefs)\n    expect(result).toEqual({ theme: 'light', fontSize: 16, notifications: false })\n  })\n\n  it('combines analytics data', () => {\n    const analytics = [\n      { pageViews: 100, uniqueVisitors: 50, avgTimeOnSite: 60 },\n      { pageViews: 150, uniqueVisitors: 75, avgTimeOnSite: 90 },\n      { pageViews: 200, uniqueVisitors: 100, avgTimeOnSite: 120 },\n    ]\n    const result = combineAnalytics(analytics)\n    expect(result).toEqual({\n      pageViews: 450,\n      uniqueVisitors: 225,\n      avgTimeOnSite: 90, // (60 + 90 + 120) / 3\n    })\n  })\n})"
  },
  {
    "id": "task-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts task",
    "category": "Task",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst createTask = (value: number): T.Task<number> => {\n  //TODO: Create a Task that resolves with the given value\n  //HINT: T.of wraps a value in a Task\n}\n\n// @ts-ignore\nconst delayedTask = (value: string, ms: number): T.Task<string> => {\n  //TODO: Create a Task that resolves after a delay\n  //HINT: Use T.fromTask or wrap a Promise with T.tryCatch (but Task always succeeds)\n  //HINT: Actually use () => new Promise(resolve => setTimeout(() => resolve(value), ms))\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport { describe, it, expect } from 'vitest'\n\nexport const createTask = (value: number): T.Task<number> =>\n  T.of(value)\n\nexport const delayedTask = (value: string, ms: number): T.Task<string> =>\n  () => new Promise((resolve) => setTimeout(() => resolve(value), ms))",
    "testCode": "describe('Task basics', () => {\n  it('creates simple task', async () => {\n    const task = createTask(42)\n    const result = await task()\n    expect(result).toBe(42)\n  })\n\n  it('creates delayed task', async () => {\n    const task = delayedTask('hello', 10)\n    const result = await task()\n    expect(result).toBe('hello')\n  })\n})"
  },
  {
    "id": "task-02",
    "title": "Map",
    "description": "Learn about map in fp-ts task",
    "category": "Task",
    "fileName": "02-map.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst doubleTask = (task: T.Task<number>): T.Task<number> => {\n  //TODO: Map over the Task to double the value\n  //HINT: Use T.map\n}\n\n// @ts-ignore\nconst upperCaseTask = (task: T.Task<string>): T.Task<string> => {\n  //TODO: Map over the Task to uppercase the string\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const doubleTask = (task: T.Task<number>): T.Task<number> =>\n  pipe(\n    task,\n    T.map((n) => n * 2)\n  )\n\nexport const upperCaseTask = (task: T.Task<string>): T.Task<string> =>\n  pipe(\n    task,\n    T.map((s) => s.toUpperCase())\n  )",
    "testCode": "describe('Task map', () => {\n  it('maps task value', async () => {\n    const task = T.of(21)\n    const result = await doubleTask(task)()\n    expect(result).toBe(42)\n  })\n\n  it('uppercases task string', async () => {\n    const task = T.of('hello')\n    const result = await upperCaseTask(task)()\n    expect(result).toBe('HELLO')\n  })\n})"
  },
  {
    "id": "task-03",
    "title": "Chain",
    "description": "Learn about chain in fp-ts task",
    "category": "Task",
    "fileName": "03-chain.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst fetchUser = (id: number): T.Task<{ id: number; name: string; companyId: number }> =>\n  T.of({ id, name: `User ${id}`, companyId: id })\n\nconst fetchCompany = (companyId: number): T.Task<{ id: number; name: string }> =>\n  T.of({ id: companyId, name: `Company ${companyId}` })\n\n// @ts-ignore\nconst fetchUserWithCompany = (userId: number): T.Task<{ user: string; company: string }> => {\n  //TODO: Chain fetchUser and fetchCompany to get both names\n  //HINT: Use T.flatMap (or T.chain) to sequence async operations\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst fetchUser = (id: number): T.Task<{ id: number; name: string; companyId: number }> =>\n  T.of({ id, name: `User ${id}`, companyId: id })\n\nconst fetchCompany = (companyId: number): T.Task<{ id: number; name: string }> =>\n  T.of({ id: companyId, name: `Company ${companyId}` })\n\nexport const fetchUserWithCompany = (userId: number): T.Task<{ user: string; company: string }> =>\n  pipe(\n    fetchUser(userId),\n    T.flatMap((user) =>\n      pipe(\n        fetchCompany(user.companyId),\n        T.map((company) => ({ user: user.name, company: company.name }))\n      )\n    )\n  )",
    "testCode": "describe('Task chain', () => {\n  it('chains tasks', async () => {\n    const result = await fetchUserWithCompany(1)()\n    expect(result).toEqual({\n      user: 'User 1',\n      company: 'Company 1',\n    })\n  })\n})"
  },
  {
    "id": "task-04",
    "title": "Parallel",
    "description": "Learn about parallel in fp-ts task",
    "category": "Task",
    "fileName": "04-parallel.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst delayedValue = (value: number, ms: number): T.Task<number> =>\n  () => new Promise((resolve) => setTimeout(() => resolve(value), ms))\n\n// @ts-ignore\nconst fetchAllParallel = (ids: number[]): T.Task<number[]> => {\n  //TODO: Fetch all ids in parallel (all at once)\n  //HINT: Use A.traverse with T.ApplicativePar\n  const fetchOne = (id: number): T.Task<number> => delayedValue(id * 10, 10)\n\n  //TODO: Apply traverse\n}\n\n// @ts-ignore\nconst combineThree = (t1: T.Task<number>, t2: T.Task<number>, t3: T.Task<number>): T.Task<number> => {\n  //TODO: Run three tasks in parallel and sum results\n  //HINT: Use T.ApplicativePar with sequenceT\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport * as A from 'fp-ts/Array'\nimport * as Ap from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst delayedValue = (value: number, ms: number): T.Task<number> =>\n  () => new Promise((resolve) => setTimeout(() => resolve(value), ms))\n\nconst fetchOne = (id: number): T.Task<number> => delayedValue(id * 10, 10)\n\nexport const fetchAllParallel = (ids: number[]): T.Task<number[]> =>\n  pipe(\n    ids,\n    A.traverse(T.ApplicativePar)(fetchOne)\n  )\n\nexport const combineThree = (t1: T.Task<number>, t2: T.Task<number>, t3: T.Task<number>): T.Task<number> =>\n  pipe(\n    Ap.sequenceT(T.ApplicativePar)(t1, t2, t3),\n    T.map(([a, b, c]) => a + b + c)\n  )",
    "testCode": "describe('Task parallel execution', () => {\n  it('fetches all in parallel', async () => {\n    const start = Date.now()\n    const result = await fetchAllParallel([1, 2, 3])()\n    const duration = Date.now() - start\n\n    expect(result).toEqual([10, 20, 30])\n    expect(duration).toBeLessThan(25) // Should be ~10ms, not 30ms\n  })\n\n  it('combines three tasks in parallel', async () => {\n    const result = await combineThree(T.of(10), T.of(20), T.of(30))()\n    expect(result).toBe(60)\n  })\n})"
  },
  {
    "id": "task-05",
    "title": "Delay",
    "description": "Learn about delay in fp-ts task",
    "category": "Task",
    "fileName": "05-delay.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst delay = (ms: number): T.Task<void> => {\n  //TODO: Create a Task that delays for the given milliseconds\n  //HINT: () => new Promise(resolve => setTimeout(resolve, ms))\n}\n\n// @ts-ignore\nconst delayedComputation = <A>(value: A, ms: number): T.Task<A> => {\n  //TODO: Return the value after a delay\n  //HINT: Chain delay with a map that returns the value\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const delay = (ms: number): T.Task<void> =>\n  () => new Promise((resolve) => setTimeout(resolve, ms))\n\nexport const delayedComputation = <A>(value: A, ms: number): T.Task<A> =>\n  pipe(\n    delay(ms),\n    T.map(() => value)\n  )",
    "testCode": "describe('Task delay', () => {\n  it('delays execution', async () => {\n    const start = Date.now()\n    await delay(20)()\n    const duration = Date.now() - start\n    expect(duration).toBeGreaterThanOrEqual(15)\n  })\n\n  it('delays computation', async () => {\n    const start = Date.now()\n    const result = await delayedComputation('done', 20)()\n    const duration = Date.now() - start\n\n    expect(result).toBe('done')\n    expect(duration).toBeGreaterThanOrEqual(15)\n  })\n})"
  },
  {
    "id": "task-06",
    "title": "Practical",
    "description": "Learn about practical in fp-ts task",
    "category": "Task",
    "fileName": "06-practical.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as T from 'fp-ts/Task'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype CacheEntry = {\n  key: string\n  value: string\n}\n\n// @ts-ignore\nconst batchFetchCache = (keys: string[]): T.Task<CacheEntry[]> => {\n  //TODO: Fetch all cache entries in parallel\n  //HINT: Map keys to tasks, then sequence with A.traverse\n  const fetchOne = (key: string): T.Task<CacheEntry> =>\n    T.of({ key, value: `cached-${key}` })\n\n  //TODO: Use traverse to fetch all\n}\n\n// @ts-ignore\nconst retryWithDelay = <A>(task: T.Task<A>, delayMs: number, attempts: number): T.Task<A> => {\n  //TODO: Create a task that retries the given task with delay between attempts\n  //HINT: This is complex - for now, just run the task (retry logic would need error handling)\n  //NOTE: Task always succeeds, so retry doesn't make much sense without TaskEither\n}",
    "solutionCode": "import * as T from 'fp-ts/Task'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype CacheEntry = {\n  key: string\n  value: string\n}\n\nconst fetchOne = (key: string): T.Task<CacheEntry> =>\n  T.of({ key, value: `cached-${key}` })\n\nexport const batchFetchCache = (keys: string[]): T.Task<CacheEntry[]> =>\n  pipe(\n    keys,\n    A.traverse(T.ApplicativePar)(fetchOne)\n  )\n\nexport const retryWithDelay = <A>(task: T.Task<A>, delayMs: number, attempts: number): T.Task<A> =>\n  task // Note: Task always succeeds, so retry without error handling just runs once",
    "testCode": "describe('Task practical examples', () => {\n  it('batch fetches cache entries', async () => {\n    const result = await batchFetchCache(['a', 'b', 'c'])()\n    expect(result).toEqual([\n      { key: 'a', value: 'cached-a' },\n      { key: 'b', value: 'cached-b' },\n      { key: 'c', value: 'cached-c' },\n    ])\n  })\n\n  it('executes task (retry example)', async () => {\n    let count = 0\n    const task: T.Task<number> = () => Promise.resolve(++count)\n    const result = await retryWithDelay(task, 10, 3)()\n    expect(result).toBeGreaterThan(0)\n  })\n})"
  },
  {
    "id": "taskeither-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst successfulTask = (): TE.TaskEither<string, number> => {\n  //TODO: Create a TaskEither that successfully returns the number 42\n  //HINT: Use TE.right for successful values\n}\n\n// @ts-ignore\nconst failedTask = (): TE.TaskEither<string, number> => {\n  //TODO: Create a TaskEither that fails with the error \"Something went wrong\"\n  //HINT: Use TE.left for error values\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { describe, it, expect } from 'vitest'\n\nexport const successfulTask = (): TE.TaskEither<string, number> =>\n  TE.right(42)\n\nexport const failedTask = (): TE.TaskEither<string, number> =>\n  TE.left('Something went wrong')",
    "testCode": "describe('TaskEither basics', () => {\n  it('creates successful TaskEither', async () => {\n    const result = await successfulTask()()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toBe(42)\n    }\n  })\n\n  it('creates failed TaskEither', async () => {\n    const result = await failedTask()()\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left).toBe('Something went wrong')\n    }\n  })\n})"
  },
  {
    "id": "taskeither-02",
    "title": "From Promise",
    "description": "Learn about from promise in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "02-from-promise.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst wrapPromise = (promise: Promise<number>): TE.TaskEither<Error, number> => {\n  //TODO: Convert a Promise to TaskEither using TE.tryCatch\n  //HINT: TE.tryCatch takes the promise function and an error handler\n}\n\n// @ts-ignore\nconst safeFetch = (url: string): TE.TaskEither<string, string> => {\n  //TODO: Wrap a fetch call in TaskEither\n  //HINT: Use TE.tryCatch and handle errors by converting them to strings\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { describe, it, expect } from 'vitest'\n\nexport const wrapPromise = (promise: Promise<number>): TE.TaskEither<Error, number> =>\n  TE.tryCatch(\n    () => promise,\n    (error) => error as Error\n  )\n\nexport const safeFetch = (url: string): TE.TaskEither<string, string> =>\n  TE.tryCatch(\n    () => fetch(url).then((res) => res.text()),\n    (error) => String(error)\n  )",
    "testCode": "describe('TaskEither from Promise', () => {\n  it('converts successful promise', async () => {\n    const promise = Promise.resolve(100)\n    const result = await wrapPromise(promise)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toBe(100)\n    }\n  })\n\n  it('converts failed promise', async () => {\n    const promise = Promise.reject(new Error('Failed'))\n    const result = await wrapPromise(promise)()\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.message).toBe('Failed')\n    }\n  })\n})"
  },
  {
    "id": "taskeither-03",
    "title": "Chaining",
    "description": "Learn about chaining in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "03-chaining.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst fetchUser = (id: number): TE.TaskEither<string, { id: number; name: string; companyId: number }> => {\n  //TODO: Simulate fetching a user - return Right for valid ids (> 0), Left otherwise\n}\n\n// @ts-ignore\nconst fetchCompany = (companyId: number): TE.TaskEither<string, { id: number; name: string }> => {\n  //TODO: Simulate fetching a company - return Right for valid ids (> 0), Left otherwise\n}\n\n// @ts-ignore\nconst fetchUserWithCompany = (userId: number): TE.TaskEither<string, { user: string; company: string }> => {\n  //TODO: Chain fetchUser and fetchCompany to get both user and company name\n  //HINT: Use pipe with TE.flatMap (or TE.chain) to sequence async operations\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const fetchUser = (id: number): TE.TaskEither<string, { id: number; name: string; companyId: number }> =>\n  id > 0\n    ? TE.right({ id, name: `User ${id}`, companyId: id })\n    : TE.left('Invalid user id')\n\nexport const fetchCompany = (companyId: number): TE.TaskEither<string, { id: number; name: string }> =>\n  companyId > 0\n    ? TE.right({ id: companyId, name: `Company ${companyId}` })\n    : TE.left('Invalid company id')\n\nexport const fetchUserWithCompany = (userId: number): TE.TaskEither<string, { user: string; company: string }> =>\n  pipe(\n    fetchUser(userId),\n    TE.flatMap((user) =>\n      pipe(\n        fetchCompany(user.companyId),\n        TE.map((company) => ({ user: user.name, company: company.name }))\n      )\n    )\n  )",
    "testCode": "describe('TaskEither chaining', () => {\n  it('chains successful operations', async () => {\n    const result = await fetchUserWithCompany(1)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual({ user: 'User 1', company: 'Company 1' })\n    }\n  })\n\n  it('fails on invalid user id', async () => {\n    const result = await fetchUserWithCompany(0)()\n    expect(result._tag).toBe('Left')\n  })\n})"
  },
  {
    "id": "taskeither-04",
    "title": "Map",
    "description": "Learn about map in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "04-map.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst doubleSuccess = (te: TE.TaskEither<string, number>): TE.TaskEither<string, number> => {\n  //TODO: Use TE.map to double the success value\n}\n\n// @ts-ignore\nconst prefixError = (te: TE.TaskEither<string, number>): TE.TaskEither<string, number> => {\n  //TODO: Use TE.mapLeft to prefix the error with \"ERROR: \"\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const doubleSuccess = (te: TE.TaskEither<string, number>): TE.TaskEither<string, number> =>\n  pipe(\n    te,\n    TE.map((n) => n * 2)\n  )\n\nexport const prefixError = (te: TE.TaskEither<string, number>): TE.TaskEither<string, number> =>\n  pipe(\n    te,\n    TE.mapLeft((err) => `ERROR: ${err}`)\n  )",
    "testCode": "describe('TaskEither map operations', () => {\n  it('maps success value', async () => {\n    const task = TE.right(21)\n    const result = await doubleSuccess(task)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toBe(42)\n    }\n  })\n\n  it('does not affect errors on map', async () => {\n    const task = TE.left('error')\n    const result = await doubleSuccess(task)()\n    expect(result._tag).toBe('Left')\n  })\n\n  it('maps error value', async () => {\n    const task = TE.left('failure')\n    const result = await prefixError(task)()\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left).toBe('ERROR: failure')\n    }\n  })\n\n  it('does not affect success on mapLeft', async () => {\n    const task = TE.right(42)\n    const result = await prefixError(task)()\n    expect(result._tag).toBe('Right')\n  })\n})"
  },
  {
    "id": "taskeither-05",
    "title": "Fold",
    "description": "Learn about fold in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "05-fold.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst getMessage = (te: TE.TaskEither<string, number>): Promise<string> => {\n  //TODO: Use TE.match (formerly fold) to handle both success and error cases\n  //HINT: On error return \"Error: {error}\", on success return \"Success: {value}\"\n}\n\n// @ts-ignore\nconst getWithDefault = (te: TE.TaskEither<string, number>): Promise<number> => {\n  //TODO: Use TE.getOrElse to return the success value or default to 0 on error\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const getMessage = (te: TE.TaskEither<string, number>): Promise<string> =>\n  pipe(\n    te,\n    TE.match(\n      (error) => `Error: ${error}`,\n      (value) => `Success: ${value}`\n    )\n  )()\n\nexport const getWithDefault = (te: TE.TaskEither<string, number>): Promise<number> =>\n  pipe(\n    te,\n    TE.getOrElse(() => () => Promise.resolve(0))\n  )()",
    "testCode": "describe('TaskEither fold operations', () => {\n  it('matches success case', async () => {\n    const task = TE.right(42)\n    const result = await getMessage(task)\n    expect(result).toBe('Success: 42')\n  })\n\n  it('matches error case', async () => {\n    const task = TE.left('failed')\n    const result = await getMessage(task)\n    expect(result).toBe('Error: failed')\n  })\n\n  it('gets success value', async () => {\n    const task = TE.right(100)\n    const result = await getWithDefault(task)\n    expect(result).toBe(100)\n  })\n\n  it('gets default on error', async () => {\n    const task = TE.left('error')\n    const result = await getWithDefault(task)\n    expect(result).toBe(0)\n  })\n})"
  },
  {
    "id": "taskeither-06",
    "title": "Recovery",
    "description": "Learn about recovery in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "06-recovery.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst fetchWithFallback = (primaryUrl: string, fallbackUrl: string): TE.TaskEither<string, string> => {\n  //TODO: Try fetching from primaryUrl, if it fails, try fallbackUrl\n  //HINT: Use TE.orElse to provide a fallback TaskEither\n  const fetchPrimary = TE.tryCatch(\n    () => fetch(primaryUrl).then(res => res.text()),\n    () => 'Primary failed'\n  )\n\n  const fetchFallback = TE.tryCatch(\n    () => fetch(fallbackUrl).then(res => res.text()),\n    () => 'Both failed'\n  )\n\n  //TODO: Combine using orElse\n}\n\n// @ts-ignore\nconst retryOnce = (task: TE.TaskEither<string, number>): TE.TaskEither<string, number> => {\n  //TODO: If task fails, retry it once\n  //HINT: Use TE.orElse with the same task\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nexport const fetchWithFallback = (primaryUrl: string, fallbackUrl: string): TE.TaskEither<string, string> => {\n  const fetchPrimary = TE.tryCatch(\n    () => fetch(primaryUrl).then(res => res.text()),\n    () => 'Primary failed'\n  )\n\n  const fetchFallback = TE.tryCatch(\n    () => fetch(fallbackUrl).then(res => res.text()),\n    () => 'Both failed'\n  )\n\n  return pipe(\n    fetchPrimary,\n    TE.orElse(() => fetchFallback)\n  )\n}\n\nexport const retryOnce = (task: TE.TaskEither<string, number>): TE.TaskEither<string, number> =>\n  pipe(\n    task,\n    TE.orElse(() => task)\n  )",
    "testCode": "describe('TaskEither recovery', () => {\n  it('retries task on failure', async () => {\n    let attempts = 0\n    const task = TE.tryCatch(\n      async () => {\n        attempts++\n        if (attempts === 1) throw new Error('First attempt')\n        return 42\n      },\n      () => 'failed'\n    )\n\n    const result = await retryOnce(task)()\n    expect(result._tag).toBe('Right')\n    expect(attempts).toBe(2)\n  })\n\n  it('succeeds on first attempt', async () => {\n    let attempts = 0\n    const task = TE.tryCatch(\n      async () => {\n        attempts++\n        return 100\n      },\n      () => 'failed'\n    )\n\n    const result = await retryOnce(task)()\n    expect(result._tag).toBe('Right')\n    expect(attempts).toBe(1)\n  })\n})"
  },
  {
    "id": "taskeither-07",
    "title": "Sequencing",
    "description": "Learn about sequencing in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "07-sequencing.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst fetchAll = (ids: number[]): TE.TaskEither<string, number[]> => {\n  //TODO: Fetch all ids sequentially (one after another)\n  //HINT: Use A.traverse with TE.ApplicativeSeq to sequence TaskEithers\n  const fetchOne = (id: number): TE.TaskEither<string, number> =>\n    id > 0 ? TE.right(id * 10) : TE.left(`Invalid id: ${id}`)\n\n  //TODO: Apply traverse to fetch all\n}\n\n// @ts-ignore\nconst processInOrder = (numbers: number[]): TE.TaskEither<string, number[]> => {\n  //TODO: Process each number (multiply by 2) in order\n  //HINT: Map each number to a TaskEither, then sequence them\n  const process = (n: number): TE.TaskEither<string, number> =>\n    TE.right(n * 2)\n\n  //TODO: Use A.traverse to sequence the processing\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst fetchOne = (id: number): TE.TaskEither<string, number> =>\n  id > 0 ? TE.right(id * 10) : TE.left(`Invalid id: ${id}`)\n\nexport const fetchAll = (ids: number[]): TE.TaskEither<string, number[]> =>\n  pipe(\n    ids,\n    A.traverse(TE.ApplicativeSeq)(fetchOne)\n  )\n\nconst process = (n: number): TE.TaskEither<string, number> =>\n  TE.right(n * 2)\n\nexport const processInOrder = (numbers: number[]): TE.TaskEither<string, number[]> =>\n  pipe(\n    numbers,\n    A.traverse(TE.ApplicativeSeq)(process)\n  )",
    "testCode": "describe('TaskEither sequencing', () => {\n  it('fetches all successfully', async () => {\n    const result = await fetchAll([1, 2, 3])()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual([10, 20, 30])\n    }\n  })\n\n  it('fails on first error', async () => {\n    const result = await fetchAll([1, 0, 3])()\n    expect(result._tag).toBe('Left')\n  })\n\n  it('processes in order', async () => {\n    const result = await processInOrder([5, 10, 15])()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual([10, 20, 30])\n    }\n  })\n})"
  },
  {
    "id": "taskeither-08",
    "title": "Parallel",
    "description": "Learn about parallel in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "08-parallel.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst fetchAllParallel = (ids: number[]): TE.TaskEither<string, number[]> => {\n  //TODO: Fetch all ids in parallel (all at once)\n  //HINT: Use A.traverse with TE.ApplicativePar for parallel execution\n  const fetchOne = (id: number): TE.TaskEither<string, number> =>\n    TE.tryCatch(\n      () => new Promise<number>((resolve) => setTimeout(() => resolve(id * 10), 10)),\n      () => `Failed to fetch ${id}`\n    )\n\n  //TODO: Use traverse with ApplicativePar\n}\n\n// @ts-ignore\nconst combineResults = (\n  task1: TE.TaskEither<string, number>,\n  task2: TE.TaskEither<string, number>,\n  task3: TE.TaskEither<string, number>\n): TE.TaskEither<string, number> => {\n  //TODO: Run all three tasks in parallel and sum their results\n  //HINT: Use TE.Do notation or sequenceT to combine multiple TaskEithers\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst fetchOne = (id: number): TE.TaskEither<string, number> =>\n  TE.tryCatch(\n    () => new Promise<number>((resolve) => setTimeout(() => resolve(id * 10), 10)),\n    () => `Failed to fetch ${id}`\n  )\n\nexport const fetchAllParallel = (ids: number[]): TE.TaskEither<string, number[]> =>\n  pipe(\n    ids,\n    A.traverse(TE.ApplicativePar)(fetchOne)\n  )\n\nexport const combineResults = (\n  task1: TE.TaskEither<string, number>,\n  task2: TE.TaskEither<string, number>,\n  task3: TE.TaskEither<string, number>\n): TE.TaskEither<string, number> =>\n  pipe(\n    TE.Do,\n    TE.bind('a', () => task1),\n    TE.bind('b', () => task2),\n    TE.bind('c', () => task3),\n    TE.map(({ a, b, c }) => a + b + c)\n  )",
    "testCode": "describe('TaskEither parallel execution', () => {\n  it('fetches all in parallel', async () => {\n    const start = Date.now()\n    const result = await fetchAllParallel([1, 2, 3])()\n    const duration = Date.now() - start\n\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual([10, 20, 30])\n    }\n    // Should be faster than sequential (< 25ms vs 30ms)\n    expect(duration).toBeLessThan(25)\n  })\n\n  it('combines parallel results', async () => {\n    const task1 = TE.right(10)\n    const task2 = TE.right(20)\n    const task3 = TE.right(30)\n\n    const result = await combineResults(task1, task2, task3)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toBe(60)\n    }\n  })\n})"
  },
  {
    "id": "taskeither-09",
    "title": "Api",
    "description": "Learn about api in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "09-api.exercise.ts",
    "difficulty": "advanced",
    "order": 9,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ApiError = {\n  status: number\n  message: string\n}\n\ntype User = {\n  id: number\n  name: string\n  email: string\n}\n\n// @ts-ignore\nconst parseJSON = <T>(response: Response): TE.TaskEither<ApiError, T> => {\n  //TODO: Parse JSON from response, handle errors\n  //HINT: Use TE.tryCatch and check response.ok first\n}\n\n// @ts-ignore\nconst fetchUser = (id: number): TE.TaskEither<ApiError, User> => {\n  //TODO: Fetch user from API and parse JSON\n  //HINT: Chain TE.tryCatch for fetch, then parseJSON\n  // Mock implementation: return success for id > 0\n  if (id > 0) {\n    return TE.right({ id, name: `User ${id}`, email: `user${id}@example.com` })\n  }\n  return TE.left({ status: 404, message: 'User not found' })\n}\n\n// @ts-ignore\nconst updateUserEmail = (userId: number, newEmail: string): TE.TaskEither<ApiError, User> => {\n  //TODO: Fetch user, then update their email\n  //HINT: Chain fetchUser with a map to update the email\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ApiError = {\n  status: number\n  message: string\n}\n\ntype User = {\n  id: number\n  name: string\n  email: string\n}\n\nexport const parseJSON = <T>(response: Response): TE.TaskEither<ApiError, T> =>\n  TE.tryCatch(\n    () => response.json() as Promise<T>,\n    () => ({ status: response.status, message: 'Failed to parse JSON' })\n  )\n\nexport const fetchUser = (id: number): TE.TaskEither<ApiError, User> => {\n  if (id > 0) {\n    return TE.right({ id, name: `User ${id}`, email: `user${id}@example.com` })\n  }\n  return TE.left({ status: 404, message: 'User not found' })\n}\n\nexport const updateUserEmail = (userId: number, newEmail: string): TE.TaskEither<ApiError, User> =>\n  pipe(\n    fetchUser(userId),\n    TE.map((user) => ({ ...user, email: newEmail }))\n  )",
    "testCode": "describe('TaskEither API operations', () => {\n  it('fetches user successfully', async () => {\n    const result = await fetchUser(1)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right.id).toBe(1)\n      expect(result.right.name).toBe('User 1')\n    }\n  })\n\n  it('handles API error', async () => {\n    const result = await fetchUser(0)()\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.status).toBe(404)\n    }\n  })\n\n  it('updates user email', async () => {\n    const result = await updateUserEmail(1, 'newemail@example.com')()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right.email).toBe('newemail@example.com')\n    }\n  })\n})"
  },
  {
    "id": "taskeither-10",
    "title": "Pipeline",
    "description": "Learn about pipeline in fp-ts taskeither",
    "category": "Taskeither",
    "fileName": "10-pipeline.exercise.ts",
    "difficulty": "advanced",
    "order": 10,
    "exerciseCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = string[]\ntype User = { id: number; email: string; age: number }\ntype ProcessedUser = { id: number; email: string; ageGroup: string }\n\n// @ts-ignore\nconst validateUser = (user: User): TE.TaskEither<ValidationError, User> => {\n  //TODO: Validate user (email must contain @, age must be 18+)\n  //HINT: Collect errors in an array, return left if any errors\n  const errors: string[] = []\n  if (!user.email.includes('@')) errors.push('Invalid email')\n  if (user.age < 18) errors.push('User must be 18+')\n\n  //TODO: Return left with errors or right with user\n}\n\n// @ts-ignore\nconst enrichUser = (user: User): TE.TaskEither<ValidationError, ProcessedUser> => {\n  //TODO: Add age group (18-30: 'young', 31-50: 'middle', 50+: 'senior')\n  //HINT: Map the user and add the ageGroup field\n}\n\n// @ts-ignore\nconst processUsers = (users: User[]): TE.TaskEither<ValidationError, ProcessedUser[]> => {\n  //TODO: Create a complete pipeline:\n  // 1. Validate each user (fail fast on first invalid)\n  // 2. Enrich each valid user with age group\n  // 3. Return array of processed users\n  //HINT: Use A.traverse to sequence the operations\n}",
    "solutionCode": "import * as TE from 'fp-ts/TaskEither'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = string[]\ntype User = { id: number; email: string; age: number }\ntype ProcessedUser = { id: number; email: string; ageGroup: string }\n\nexport const validateUser = (user: User): TE.TaskEither<ValidationError, User> => {\n  const errors: string[] = []\n  if (!user.email.includes('@')) errors.push('Invalid email')\n  if (user.age < 18) errors.push('User must be 18+')\n\n  return errors.length > 0 ? TE.left(errors) : TE.right(user)\n}\n\nexport const enrichUser = (user: User): TE.TaskEither<ValidationError, ProcessedUser> =>\n  pipe(\n    TE.right(user),\n    TE.map((u) => ({\n      id: u.id,\n      email: u.email,\n      ageGroup: u.age <= 30 ? 'young' : u.age <= 50 ? 'middle' : 'senior',\n    }))\n  )\n\nexport const processUsers = (users: User[]): TE.TaskEither<ValidationError, ProcessedUser[]> =>\n  pipe(\n    users,\n    A.traverse(TE.ApplicativeSeq)((user) =>\n      pipe(\n        validateUser(user),\n        TE.flatMap(enrichUser)\n      )\n    )\n  )",
    "testCode": "describe('TaskEither complex pipeline', () => {\n  it('processes valid users', async () => {\n    const users: User[] = [\n      { id: 1, email: 'alice@example.com', age: 25 },\n      { id: 2, email: 'bob@example.com', age: 35 },\n      { id: 3, email: 'charlie@example.com', age: 55 },\n    ]\n\n    const result = await processUsers(users)()\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual([\n        { id: 1, email: 'alice@example.com', ageGroup: 'young' },\n        { id: 2, email: 'bob@example.com', ageGroup: 'middle' },\n        { id: 3, email: 'charlie@example.com', ageGroup: 'senior' },\n      ])\n    }\n  })\n\n  it('fails on invalid user', async () => {\n    const users: User[] = [\n      { id: 1, email: 'alice@example.com', age: 25 },\n      { id: 2, email: 'invalid-email', age: 16 },\n    ]\n\n    const result = await processUsers(users)()\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(0)\n    }\n  })\n})"
  },
  {
    "id": "validation-01",
    "title": "Basic",
    "description": "Learn about basic in fp-ts validation",
    "category": "Validation",
    "fileName": "01-basic.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\n// @ts-ignore\nconst validateAge = (age: number): E.Either<string, number> => {\n  //TODO: Validate that age is between 0 and 120\n  //HINT: Return E.left with error message or E.right with age\n}\n\n// @ts-ignore\nconst validateEmail = (email: string): E.Either<string, string> => {\n  //TODO: Validate that email contains @ symbol\n  //HINT: Return E.left with error or E.right with email\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\nexport const validateAge = (age: number): E.Either<string, number> => {\n  if (age < 0 || age > 120) {\n    return E.left('Age must be between 0 and 120')\n  }\n  return E.right(age)\n}\n\nexport const validateEmail = (email: string): E.Either<string, string> => {\n  if (!email.includes('@')) {\n    return E.left('Email must contain @')\n  }\n  return E.right(email)\n}",
    "testCode": "describe('Validation basics', () => {\n  it('validates age successfully', () => {\n    const result = validateAge(25)\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toBe(25)\n    }\n  })\n\n  it('rejects invalid age', () => {\n    expect(validateAge(-5)._tag).toBe('Left')\n    expect(validateAge(150)._tag).toBe('Left')\n  })\n\n  it('validates email successfully', () => {\n    const result = validateEmail('user@example.com')\n    expect(result._tag).toBe('Right')\n  })\n\n  it('rejects invalid email', () => {\n    const result = validateEmail('invalid-email')\n    expect(result._tag).toBe('Left')\n  })\n})"
  },
  {
    "id": "validation-02",
    "title": "Accumulate",
    "description": "Learn about accumulate in fp-ts validation",
    "category": "Validation",
    "fileName": "02-accumulate.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = string[]\n\n// @ts-ignore\nconst validateName = (name: string): E.Either<ValidationError, string> => {\n  //TODO: Validate name (non-empty, min 2 chars, max 50 chars)\n  //HINT: Collect all errors in an array, return Left with errors or Right with name\n}\n\n// @ts-ignore\nconst validatePassword = (password: string): E.Either<ValidationError, string> => {\n  //TODO: Validate password (min 8 chars, has uppercase, has number)\n  //HINT: Collect all validation errors\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Array'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = string[]\n\nexport const validateName = (name: string): E.Either<ValidationError, string> => {\n  const errors: string[] = []\n  if (name.length === 0) errors.push('Name cannot be empty')\n  if (name.length < 2) errors.push('Name must be at least 2 characters')\n  if (name.length > 50) errors.push('Name must be at most 50 characters')\n\n  return errors.length > 0 ? E.left(errors) : E.right(name)\n}\n\nexport const validatePassword = (password: string): E.Either<ValidationError, string> => {\n  const errors: string[] = []\n  if (password.length < 8) errors.push('Password must be at least 8 characters')\n  if (!/[A-Z]/.test(password)) errors.push('Password must contain uppercase letter')\n  if (!/[0-9]/.test(password)) errors.push('Password must contain a number')\n\n  return errors.length > 0 ? E.left(errors) : E.right(password)\n}",
    "testCode": "describe('Accumulating validation errors', () => {\n  it('validates correct name', () => {\n    const result = validateName('Alice')\n    expect(result._tag).toBe('Right')\n  })\n\n  it('accumulates name errors', () => {\n    const result = validateName('A')\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(0)\n    }\n  })\n\n  it('validates correct password', () => {\n    const result = validatePassword('SecurePass123')\n    expect(result._tag).toBe('Right')\n  })\n\n  it('accumulates password errors', () => {\n    const result = validatePassword('weak')\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(1) // Multiple errors\n    }\n  })\n})"
  },
  {
    "id": "validation-03",
    "title": "Applicative",
    "description": "Learn about applicative in fp-ts validation",
    "category": "Validation",
    "fileName": "03-applicative.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype User = {\n  name: string\n  email: string\n  age: number\n}\n\nconst validateName = (name: string): E.Either<ValidationErrors, string> =>\n  name.length >= 2 ? E.right(name) : E.left(['Name too short'])\n\nconst validateEmail = (email: string): E.Either<ValidationErrors, string> =>\n  email.includes('@') ? E.right(email) : E.left(['Invalid email'])\n\nconst validateAge = (age: number): E.Either<ValidationErrors, number> =>\n  age >= 18 ? E.right(age) : E.left(['Must be 18 or older'])\n\n// @ts-ignore\nconst validateUser = (name: string, email: string, age: number): E.Either<ValidationErrors, User> => {\n  //TODO: Validate all fields and accumulate ALL errors\n  //HINT: Use E.getApplicativeValidation with a Semigroup that concatenates error arrays\n  //HINT: Then use sequenceT or Do notation to combine validations\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype User = {\n  name: string\n  email: string\n  age: number\n}\n\nconst validateName = (name: string): E.Either<ValidationErrors, string> =>\n  name.length >= 2 ? E.right(name) : E.left(['Name too short'])\n\nconst validateEmail = (email: string): E.Either<ValidationErrors, string> =>\n  email.includes('@') ? E.right(email) : E.left(['Invalid email'])\n\nconst validateAge = (age: number): E.Either<ValidationErrors, number> =>\n  age >= 18 ? E.right(age) : E.left(['Must be 18 or older'])\n\nconst ArraySemigroup = <T>(): { concat: (x: T[], y: T[]) => T[] } => ({\n  concat: (x, y) => [...x, ...y],\n})\n\nexport const validateUser = (name: string, email: string, age: number): E.Either<ValidationErrors, User> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateName(name),\n      validateEmail(email),\n      validateAge(age)\n    ),\n    E.map(([validName, validEmail, validAge]) => ({\n      name: validName,\n      email: validEmail,\n      age: validAge,\n    }))\n  )\n}",
    "testCode": "describe('Applicative validation', () => {\n  it('validates correct user', () => {\n    const result = validateUser('Alice', 'alice@example.com', 25)\n    expect(result._tag).toBe('Right')\n    if (result._tag === 'Right') {\n      expect(result.right).toEqual({ name: 'Alice', email: 'alice@example.com', age: 25 })\n    }\n  })\n\n  it('accumulates all validation errors', () => {\n    const result = validateUser('A', 'invalid', 16)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBe(3) // All three validations failed\n      expect(result.left).toContain('Name too short')\n      expect(result.left).toContain('Invalid email')\n      expect(result.left).toContain('Must be 18 or older')\n    }\n  })\n\n  it('accumulates partial errors', () => {\n    const result = validateUser('Alice', 'invalid', 25)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBe(1)\n    }\n  })\n})"
  },
  {
    "id": "validation-04",
    "title": "Form",
    "description": "Learn about form in fp-ts validation",
    "category": "Validation",
    "fileName": "04-form.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype RegistrationForm = {\n  username: string\n  email: string\n  password: string\n  confirmPassword: string\n}\n\ntype ValidatedForm = {\n  username: string\n  email: string\n  password: string\n}\n\n// @ts-ignore\nconst validateForm = (form: RegistrationForm): E.Either<ValidationErrors, ValidatedForm> => {\n  //TODO: Validate the entire form and accumulate all errors:\n  // - username: min 3 chars, max 20 chars, alphanumeric only\n  // - email: contains @ and .\n  // - password: min 8 chars, has uppercase, has lowercase, has number\n  // - confirmPassword: matches password\n  //HINT: Create individual validators, then combine with applicative\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype RegistrationForm = {\n  username: string\n  email: string\n  password: string\n  confirmPassword: string\n}\n\ntype ValidatedForm = {\n  username: string\n  email: string\n  password: string\n}\n\nconst ArraySemigroup = <T>(): { concat: (x: T[], y: T[]) => T[] } => ({\n  concat: (x, y) => [...x, ...y],\n})\n\nconst validateUsername = (username: string): E.Either<ValidationErrors, string> => {\n  const errors: string[] = []\n  if (username.length < 3) errors.push('Username must be at least 3 characters')\n  if (username.length > 20) errors.push('Username must be at most 20 characters')\n  if (!/^[a-zA-Z0-9]+$/.test(username)) errors.push('Username must be alphanumeric')\n  return errors.length > 0 ? E.left(errors) : E.right(username)\n}\n\nconst validateEmail = (email: string): E.Either<ValidationErrors, string> => {\n  const errors: string[] = []\n  if (!email.includes('@')) errors.push('Email must contain @')\n  if (!email.includes('.')) errors.push('Email must contain .')\n  return errors.length > 0 ? E.left(errors) : E.right(email)\n}\n\nconst validatePassword = (password: string, confirmPassword: string): E.Either<ValidationErrors, string> => {\n  const errors: string[] = []\n  if (password.length < 8) errors.push('Password must be at least 8 characters')\n  if (!/[A-Z]/.test(password)) errors.push('Password must contain uppercase letter')\n  if (!/[a-z]/.test(password)) errors.push('Password must contain lowercase letter')\n  if (!/[0-9]/.test(password)) errors.push('Password must contain a number')\n  if (password !== confirmPassword) errors.push('Passwords do not match')\n  return errors.length > 0 ? E.left(errors) : E.right(password)\n}\n\nexport const validateForm = (form: RegistrationForm): E.Either<ValidationErrors, ValidatedForm> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateUsername(form.username),\n      validateEmail(form.email),\n      validatePassword(form.password, form.confirmPassword)\n    ),\n    E.map(([username, email, password]) => ({ username, email, password }))\n  )\n}",
    "testCode": "describe('Form validation', () => {\n  it('validates correct form', () => {\n    const form = {\n      username: 'alice123',\n      email: 'alice@example.com',\n      password: 'SecurePass123',\n      confirmPassword: 'SecurePass123',\n    }\n    const result = validateForm(form)\n    expect(result._tag).toBe('Right')\n  })\n\n  it('accumulates all form errors', () => {\n    const form = {\n      username: 'a!',\n      email: 'invalid',\n      password: 'weak',\n      confirmPassword: 'different',\n    }\n    const result = validateForm(form)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(3)\n    }\n  })\n\n  it('detects password mismatch', () => {\n    const form = {\n      username: 'alice',\n      email: 'alice@example.com',\n      password: 'SecurePass123',\n      confirmPassword: 'DifferentPass123',\n    }\n    const result = validateForm(form)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left).toContain('Passwords do not match')\n    }\n  })\n})"
  },
  {
    "id": "validation-05",
    "title": "Comparison",
    "description": "Learn about comparison in fp-ts validation",
    "category": "Validation",
    "fileName": "05-comparison.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype User = { name: string; age: number }\n\n// Fail-fast behavior (Either with chain)\n// @ts-ignore\nconst validateUserEither = (name: string, age: number): E.Either<string, User> => {\n  //TODO: Validate using Either chaining (fail on first error)\n  //HINT: Use pipe with E.fromPredicate and E.flatMap\n}\n\n// Accumulate errors (Validation)\n// @ts-ignore\nconst validateUserValidation = (name: string, age: number): E.Either<string[], User> => {\n  //TODO: Validate using applicative validation (collect all errors)\n  //HINT: Use sequenceT with getApplicativeValidation\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype User = { name: string; age: number }\n\nexport const validateUserEither = (name: string, age: number): E.Either<string, User> =>\n  pipe(\n    E.Do,\n    E.bind('name', () =>\n      name.length > 0 ? E.right(name) : E.left('Name cannot be empty')\n    ),\n    E.bind('age', () =>\n      age >= 0 ? E.right(age) : E.left('Age must be non-negative')\n    ),\n    E.map(({ name, age }) => ({ name, age }))\n  )\n\nconst ArraySemigroup = <T>(): { concat: (x: T[], y: T[]) => T[] } => ({\n  concat: (x, y) => [...x, ...y],\n})\n\nexport const validateUserValidation = (name: string, age: number): E.Either<string[], User> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  const validateName = (n: string): E.Either<string[], string> =>\n    n.length > 0 ? E.right(n) : E.left(['Name cannot be empty'])\n\n  const validateAge = (a: number): E.Either<string[], number> =>\n    a >= 0 ? E.right(a) : E.left(['Age must be non-negative'])\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(validateName(name), validateAge(age)),\n    E.map(([name, age]) => ({ name, age }))\n  )\n}",
    "testCode": "describe('Either vs Validation comparison', () => {\n  it('Either fails fast', () => {\n    const result = validateUserEither('', -5)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      // Only gets first error\n      expect(typeof result.left).toBe('string')\n    }\n  })\n\n  it('Validation accumulates errors', () => {\n    const result = validateUserValidation('', -5)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      // Gets both errors\n      expect(result.left.length).toBe(2)\n    }\n  })\n\n  it('Both succeed with valid input', () => {\n    const result1 = validateUserEither('Alice', 25)\n    const result2 = validateUserValidation('Alice', 25)\n    expect(result1._tag).toBe('Right')\n    expect(result2._tag).toBe('Right')\n  })\n})"
  },
  {
    "id": "validation-06",
    "title": "Nested",
    "description": "Learn about nested in fp-ts validation",
    "category": "Validation",
    "fileName": "06-nested.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype Address = {\n  street: string\n  city: string\n  zipCode: string\n}\n\ntype Person = {\n  name: string\n  address: Address\n}\n\n// @ts-ignore\nconst validateAddress = (address: Partial<Address>): E.Either<ValidationErrors, Address> => {\n  //TODO: Validate all address fields and accumulate errors\n  // - street: non-empty\n  // - city: non-empty\n  // - zipCode: 5 digits\n}\n\n// @ts-ignore\nconst validatePerson = (person: Partial<Person & { address: Partial<Address> }>): E.Either<ValidationErrors, Person> => {\n  //TODO: Validate person including nested address validation\n  // - name: non-empty\n  // - address: use validateAddress\n  //HINT: Combine name validation and address validation with applicative\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype Address = {\n  street: string\n  city: string\n  zipCode: string\n}\n\ntype Person = {\n  name: string\n  address: Address\n}\n\nconst ArraySemigroup = <T>(): { concat: (x: T[], y: T[]) => T[] } => ({\n  concat: (x, y) => [...x, ...y],\n})\n\nexport const validateAddress = (address: Partial<Address>): E.Either<ValidationErrors, Address> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  const validateStreet = (street?: string): E.Either<ValidationErrors, string> =>\n    street && street.length > 0 ? E.right(street) : E.left(['Street is required'])\n\n  const validateCity = (city?: string): E.Either<ValidationErrors, string> =>\n    city && city.length > 0 ? E.right(city) : E.left(['City is required'])\n\n  const validateZipCode = (zipCode?: string): E.Either<ValidationErrors, string> =>\n    zipCode && /^\\d{5}$/.test(zipCode) ? E.right(zipCode) : E.left(['Zip code must be 5 digits'])\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateStreet(address.street),\n      validateCity(address.city),\n      validateZipCode(address.zipCode)\n    ),\n    E.map(([street, city, zipCode]) => ({ street, city, zipCode }))\n  )\n}\n\nexport const validatePerson = (person: Partial<Person & { address: Partial<Address> }>): E.Either<ValidationErrors, Person> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  const validateName = (name?: string): E.Either<ValidationErrors, string> =>\n    name && name.length > 0 ? E.right(name) : E.left(['Name is required'])\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateName(person.name),\n      validateAddress(person.address || {})\n    ),\n    E.map(([name, address]) => ({ name, address }))\n  )\n}",
    "testCode": "describe('Nested validation', () => {\n  it('validates complete person with address', () => {\n    const person = {\n      name: 'Alice',\n      address: { street: '123 Main St', city: 'Boston', zipCode: '02101' },\n    }\n    const result = validatePerson(person)\n    expect(result._tag).toBe('Right')\n  })\n\n  it('accumulates errors from all levels', () => {\n    const person = {\n      name: '',\n      address: { street: '', city: '', zipCode: '123' },\n    }\n    const result = validatePerson(person)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(2) // Errors from both person and address\n    }\n  })\n})"
  },
  {
    "id": "validation-07",
    "title": "Real World",
    "description": "Learn about real world in fp-ts validation",
    "category": "Validation",
    "fileName": "07-real-world.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype CreditCard = {\n  number: string\n  cvv: string\n  expiryMonth: number\n  expiryYear: number\n}\n\ntype PaymentRequest = {\n  amount: number\n  currency: string\n  card: CreditCard\n  billingName: string\n}\n\n// @ts-ignore\nconst validatePaymentRequest = (request: Partial<PaymentRequest & { card: Partial<CreditCard> }>): E.Either<ValidationErrors, PaymentRequest> => {\n  //TODO: Validate complete payment request:\n  // - amount: > 0\n  // - currency: USD, EUR, or GBP\n  // - card.number: 16 digits\n  // - card.cvv: 3 or 4 digits\n  // - card.expiryMonth: 1-12\n  // - card.expiryYear: >= current year\n  // - billingName: non-empty\n  //HINT: Break into smaller validators, combine with applicative\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport * as A from 'fp-ts/Apply'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationErrors = string[]\n\ntype CreditCard = {\n  number: string\n  cvv: string\n  expiryMonth: number\n  expiryYear: number\n}\n\ntype PaymentRequest = {\n  amount: number\n  currency: string\n  card: CreditCard\n  billingName: string\n}\n\nconst ArraySemigroup = <T>(): { concat: (x: T[], y: T[]) => T[] } => ({\n  concat: (x, y) => [...x, ...y],\n})\n\nconst validateAmount = (amount?: number): E.Either<ValidationErrors, number> =>\n  amount && amount > 0 ? E.right(amount) : E.left(['Amount must be greater than 0'])\n\nconst validateCurrency = (currency?: string): E.Either<ValidationErrors, string> =>\n  currency && ['USD', 'EUR', 'GBP'].includes(currency)\n    ? E.right(currency)\n    : E.left(['Currency must be USD, EUR, or GBP'])\n\nconst validateCard = (card: Partial<CreditCard>): E.Either<ValidationErrors, CreditCard> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  const validateNumber = (number?: string): E.Either<ValidationErrors, string> =>\n    number && /^\\d{16}$/.test(number) ? E.right(number) : E.left(['Card number must be 16 digits'])\n\n  const validateCVV = (cvv?: string): E.Either<ValidationErrors, string> =>\n    cvv && /^\\d{3,4}$/.test(cvv) ? E.right(cvv) : E.left(['CVV must be 3 or 4 digits'])\n\n  const validateMonth = (month?: number): E.Either<ValidationErrors, number> =>\n    month && month >= 1 && month <= 12 ? E.right(month) : E.left(['Expiry month must be 1-12'])\n\n  const validateYear = (year?: number): E.Either<ValidationErrors, number> =>\n    year && year >= new Date().getFullYear()\n      ? E.right(year)\n      : E.left(['Expiry year must be current year or later'])\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateNumber(card.number),\n      validateCVV(card.cvv),\n      validateMonth(card.expiryMonth),\n      validateYear(card.expiryYear)\n    ),\n    E.map(([number, cvv, expiryMonth, expiryYear]) => ({ number, cvv, expiryMonth, expiryYear }))\n  )\n}\n\nconst validateBillingName = (name?: string): E.Either<ValidationErrors, string> =>\n  name && name.length > 0 ? E.right(name) : E.left(['Billing name is required'])\n\nexport const validatePaymentRequest = (request: Partial<PaymentRequest & { card: Partial<CreditCard> }>): E.Either<ValidationErrors, PaymentRequest> => {\n  const applicativeValidation = E.getApplicativeValidation(ArraySemigroup<string>())\n\n  return pipe(\n    A.sequenceT(applicativeValidation)(\n      validateAmount(request.amount),\n      validateCurrency(request.currency),\n      validateCard(request.card || {}),\n      validateBillingName(request.billingName)\n    ),\n    E.map(([amount, currency, card, billingName]) => ({ amount, currency, card, billingName }))\n  )\n}",
    "testCode": "describe('Real-world validation', () => {\n  it('validates complete payment request', () => {\n    const request = {\n      amount: 100,\n      currency: 'USD',\n      card: {\n        number: '1234567812345678',\n        cvv: '123',\n        expiryMonth: 12,\n        expiryYear: 2026,\n      },\n      billingName: 'Alice Johnson',\n    }\n    const result = validatePaymentRequest(request)\n    expect(result._tag).toBe('Right')\n  })\n\n  it('accumulates all payment validation errors', () => {\n    const request = {\n      amount: -50,\n      currency: 'INVALID',\n      card: {\n        number: '123',\n        cvv: '12345',\n        expiryMonth: 13,\n        expiryYear: 2020,\n      },\n      billingName: '',\n    }\n    const result = validatePaymentRequest(request)\n    expect(result._tag).toBe('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.length).toBeGreaterThan(5)\n    }\n  })\n})"
  }
]

// Export alias for convenience
export const exercises = generatedExercises
