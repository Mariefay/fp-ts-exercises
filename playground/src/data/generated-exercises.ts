// Auto-generated exercises from CLI version
// Generated on: 2026-02-07T17:43:30.762Z
// DO NOT EDIT MANUALLY - Run 'npm run generate:exercises' to regenerate

import { Exercise } from '@/types/exercise'

export const generatedExercises: Exercise[] = [
  {
    "id": "either-01",
    "title": "Left And Right",
    "description": "Learn about left and right in fp-ts either",
    "category": "Either",
    "fileName": "01-left-and-right.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserById = (id: number, users: User[]): E.Either<UserError, User> => {\n  //TODO:\n  //Check if the ID is valid (greater than 0)\n  //If invalid, return E.left with 'Invalid ID' error\n  //Try to find the user in the users array\n  //If found, return E.right with the user\n  //If not found, return E.left with 'User not found' error\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserById = (id: number, users: User[]): E.Either<UserError, User> => {\n  if (id <= 0) {\n    return E.left('Invalid ID')\n  }\n\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}",
    "testCode": "describe('getUserById', () => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' },\n  ]\n\n  it('returns left with error for invalid ID', () => {\n    const result = getUserById(0, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns right with user if found', () => {\n    const result = getUserById(2, users)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 2, name: 'Bob' } })\n  })\n\n  it('returns left with error if user not found', () => {\n    const result = getUserById(99, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "either-02",
    "title": "Map",
    "description": "Learn about map in fp-ts either",
    "category": "Either",
    "fileName": "02-map.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserError = 'User not found'\n\n// @ts-ignore\nconst getUserEmail = (userEither: E.Either<UserError, User>): E.Either<UserError, string> => {\n  //TODO:\n  //Use E.map to extract the email from the user\n  //If userEither is Right, map the user to their email\n  //If userEither is Left, the error passes through unchanged\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserError = 'User not found'\n\nexport const getUserEmail = (userEither: E.Either<UserError, User>): E.Either<UserError, string> =>\n  pipe(\n    userEither,\n    E.map(user => user.email)\n  )",
    "testCode": "describe('getUserEmail', () => {\n  const user: User = { id: 1, name: 'Alice', email: 'alice@example.com' }\n  const userRight: E.Either<UserError, User> = E.right(user)\n  const userLeft: E.Either<UserError, User> = E.left('User not found')\n\n  it('maps right value to email', () => {\n    const result = getUserEmail(userRight)\n    expect(result).toEqual({ _tag: 'Right', right: 'alice@example.com' })\n  })\n\n  it('preserves left value', () => {\n    const result = getUserEmail(userLeft)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "either-03",
    "title": "Fold",
    "description": "Learn about fold in fp-ts either",
    "category": "Either",
    "fileName": "03-fold.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserName = (userEither: E.Either<UserError, User>): string => {\n  //TODO:\n  //Use E.fold to handle both Left and Right cases\n  //If Left, return the error message as a string\n  //If Right, return the user's name\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserName = (userEither: E.Either<UserError, User>): string =>\n  pipe(\n    userEither,\n    E.fold(\n      (error) => error,\n      (user) => user.name\n    )\n  )",
    "testCode": "describe('getUserName', () => {\n  const userRight: E.Either<UserError, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft1: E.Either<UserError, User> = E.left('Invalid ID')\n  const userLeft2: E.Either<UserError, User> = E.left('User not found')\n\n  it('returns user name for right value', () => {\n    const result = getUserName(userRight)\n    expect(result).toEqual('Alice')\n  })\n\n  it('returns error message for left value - Invalid ID', () => {\n    const result = getUserName(userLeft1)\n    expect(result).toEqual('Invalid ID')\n  })\n\n  it('returns error message for left value - User not found', () => {\n    const result = getUserName(userLeft2)\n    expect(result).toEqual('User not found')\n  })\n})"
  },
  {
    "id": "either-04",
    "title": "Chain",
    "description": "Learn about chain in fp-ts either",
    "category": "Either",
    "fileName": "04-chain.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\ntype ValidationError = 'Invalid ID' | 'User not found' | 'User too young'\n\nconst findUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  if (id <= 0) return E.left('Invalid ID')\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}\n\n// @ts-ignore\nconst validateAge = (user: User): E.Either<ValidationError, User> => {\n  //TODO:\n  //Check if user.age is >= 18\n  //If yes, return E.right(user)\n  //If no, return E.left('User too young')\n}\n\n// @ts-ignore\nconst findAndValidateUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  //TODO:\n  //Use E.chain to compose findUser and validateAge\n  //First find the user, then validate their age\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\ntype ValidationError = 'Invalid ID' | 'User not found' | 'User too young'\n\nconst findUser = (id: number, users: User[]): E.Either<ValidationError, User> => {\n  if (id <= 0) return E.left('Invalid ID')\n  const user = users.find(u => u.id === id)\n  return user ? E.right(user) : E.left('User not found')\n}\n\nexport const validateAge = (user: User): E.Either<ValidationError, User> => {\n  return user.age >= 18 ? E.right(user) : E.left('User too young')\n}\n\nexport const findAndValidateUser = (id: number, users: User[]): E.Either<ValidationError, User> =>\n  pipe(\n    findUser(id, users),\n    E.chain(validateAge)\n  )",
    "testCode": "describe('findAndValidateUser', () => {\n  const users = [\n    { id: 1, name: 'Alice', age: 25 },\n    { id: 2, name: 'Bob', age: 16 },\n    { id: 3, name: 'Charlie', age: 30 },\n  ]\n\n  it('returns right with user if valid and adult', () => {\n    const result = findAndValidateUser(1, users)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice', age: 25 } })\n  })\n\n  it('returns left if ID is invalid', () => {\n    const result = findAndValidateUser(0, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns left if user not found', () => {\n    const result = findAndValidateUser(99, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n\n  it('returns left if user too young', () => {\n    const result = findAndValidateUser(2, users)\n    expect(result).toEqual({ _tag: 'Left', left: 'User too young' })\n  })\n})"
  },
  {
    "id": "either-05",
    "title": "From Predicate",
    "description": "Learn about from predicate in fp-ts either",
    "category": "Either",
    "fileName": "05-from-predicate.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\n// @ts-ignore\nconst validateAdult = (user: User): E.Either<string, User> => {\n  //TODO:\n  //Use E.fromPredicate to validate that user.age >= 18\n  //If true, return E.right(user)\n  //If false, return E.left('Must be 18 or older')\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nexport const validateAdult = (user: User): E.Either<string, User> =>\n  pipe(\n    user,\n    E.fromPredicate(\n      (u) => u.age >= 18,\n      () => 'Must be 18 or older'\n    )\n  )",
    "testCode": "describe('validateAdult', () => {\n  const adult: User = { id: 1, name: 'Alice', age: 25 }\n  const minor: User = { id: 2, name: 'Bob', age: 16 }\n\n  it('returns right for adult user', () => {\n    const result = validateAdult(adult)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice', age: 25 } })\n  })\n\n  it('returns left for minor user', () => {\n    const result = validateAdult(minor)\n    expect(result).toEqual({ _tag: 'Left', left: 'Must be 18 or older' })\n  })\n})"
  },
  {
    "id": "either-06",
    "title": "Error Handling",
    "description": "Learn about error handling in fp-ts either",
    "category": "Either",
    "fileName": "06-error-handling.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  stock: number\n}\n\ntype PurchaseError =\n  | 'Product not found'\n  | 'Out of stock'\n  | 'Insufficient funds'\n\ninterface Purchase {\n  product: Product\n  remainingBalance: number\n}\n\n// @ts-ignore\nconst purchaseProduct = (\n  productId: number,\n  balance: number,\n  products: Product[]\n): E.Either<PurchaseError, Purchase> => {\n  //TODO:\n  //1. Find the product by ID, return E.left('Product not found') if not found\n  //2. Check if product.stock > 0, return E.left('Out of stock') if not\n  //3. Check if balance >= product.price, return E.left('Insufficient funds') if not\n  //4. Return E.right with { product, remainingBalance: balance - product.price }\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  stock: number\n}\n\ntype PurchaseError =\n  | 'Product not found'\n  | 'Out of stock'\n  | 'Insufficient funds'\n\ninterface Purchase {\n  product: Product\n  remainingBalance: number\n}\n\nexport const purchaseProduct = (\n  productId: number,\n  balance: number,\n  products: Product[]\n): E.Either<PurchaseError, Purchase> => {\n  const product = products.find(p => p.id === productId)\n\n  if (!product) {\n    return E.left('Product not found')\n  }\n\n  if (product.stock === 0) {\n    return E.left('Out of stock')\n  }\n\n  if (balance < product.price) {\n    return E.left('Insufficient funds')\n  }\n\n  return E.right({\n    product,\n    remainingBalance: balance - product.price\n  })\n}",
    "testCode": "describe('purchaseProduct', () => {\n  const products = [\n    { id: 1, name: 'Laptop', price: 1000, stock: 5 },\n    { id: 2, name: 'Mouse', price: 25, stock: 0 },\n    { id: 3, name: 'Keyboard', price: 75, stock: 10 },\n  ]\n\n  it('successfully purchases product', () => {\n    const result = purchaseProduct(1, 1500, products)\n    expect(result).toEqual({\n      _tag: 'Right',\n      right: { product: products[0], remainingBalance: 500 }\n    })\n  })\n\n  it('returns error for non-existent product', () => {\n    const result = purchaseProduct(99, 1000, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Product not found' })\n  })\n\n  it('returns error for out of stock product', () => {\n    const result = purchaseProduct(2, 1000, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Out of stock' })\n  })\n\n  it('returns error for insufficient funds', () => {\n    const result = purchaseProduct(1, 500, products)\n    expect(result).toEqual({ _tag: 'Left', left: 'Insufficient funds' })\n  })\n})"
  },
  {
    "id": "either-07",
    "title": "Get Or Else",
    "description": "Learn about get or else in fp-ts either",
    "category": "Either",
    "fileName": "07-get-or-else.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'User not found'\n\n// @ts-ignore\nconst getUserName = (userEither: E.Either<UserError, User>): string => {\n  //TODO:\n  //Use E.getOrElse to extract the user's name\n  //If Right, return the user's name\n  //If Left, return 'Anonymous'\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype UserError = 'User not found'\n\nexport const getUserName = (userEither: E.Either<UserError, User>): string =>\n  pipe(\n    userEither,\n    E.map(user => user.name),\n    E.getOrElse(() => 'Anonymous')\n  )",
    "testCode": "describe('getUserName', () => {\n  const userRight: E.Either<UserError, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft: E.Either<UserError, User> = E.left('User not found')\n\n  it('returns user name for right value', () => {\n    const result = getUserName(userRight)\n    expect(result).toEqual('Alice')\n  })\n\n  it('returns default value for left', () => {\n    const result = getUserName(userLeft)\n    expect(result).toEqual('Anonymous')\n  })\n})"
  },
  {
    "id": "either-08",
    "title": "Map Left",
    "description": "Learn about map left in fp-ts either",
    "category": "Either",
    "fileName": "08-map-left.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype ErrorCode = 'ERR_NOT_FOUND' | 'ERR_INVALID_ID'\n\ninterface DetailedError {\n  code: ErrorCode\n  message: string\n  timestamp: number\n}\n\n// @ts-ignore\nconst enrichError = (\n  userEither: E.Either<ErrorCode, User>\n): E.Either<DetailedError, User> => {\n  //TODO:\n  //Use E.mapLeft to transform the error from ErrorCode to DetailedError\n  //Create a DetailedError object with:\n  // - code: the original error code\n  // - message: a user-friendly message based on the error code\n  // - timestamp: Date.now()\n  //Use pipe for functional composition\n}",
    "solutionCode": "import * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\ntype ErrorCode = 'ERR_NOT_FOUND' | 'ERR_INVALID_ID'\n\ninterface DetailedError {\n  code: ErrorCode\n  message: string\n  timestamp: number\n}\n\nexport const enrichError = (\n  userEither: E.Either<ErrorCode, User>\n): E.Either<DetailedError, User> =>\n  pipe(\n    userEither,\n    E.mapLeft((errorCode): DetailedError => ({\n      code: errorCode,\n      message: errorCode === 'ERR_NOT_FOUND' ? 'User not found' : 'Invalid user ID',\n      timestamp: Date.now()\n    }))\n  )",
    "testCode": "describe('enrichError', () => {\n  const userRight: E.Either<ErrorCode, User> = E.right({ id: 1, name: 'Alice' })\n  const userLeft1: E.Either<ErrorCode, User> = E.left('ERR_NOT_FOUND')\n  const userLeft2: E.Either<ErrorCode, User> = E.left('ERR_INVALID_ID')\n\n  it('preserves right value', () => {\n    const result = enrichError(userRight)\n    expect(result).toEqual({ _tag: 'Right', right: { id: 1, name: 'Alice' } })\n  })\n\n  it('enriches ERR_NOT_FOUND error', () => {\n    const result = enrichError(userLeft1)\n    expect(result._tag).toEqual('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.code).toEqual('ERR_NOT_FOUND')\n      expect(result.left.message).toEqual('User not found')\n      expect(typeof result.left.timestamp).toBe('number')\n    }\n  })\n\n  it('enriches ERR_INVALID_ID error', () => {\n    const result = enrichError(userLeft2)\n    expect(result._tag).toEqual('Left')\n    if (result._tag === 'Left') {\n      expect(result.left.code).toEqual('ERR_INVALID_ID')\n      expect(result.left.message).toEqual('Invalid user ID')\n      expect(typeof result.left.timestamp).toBe('number')\n    }\n  })\n})"
  },
  {
    "id": "flow-01",
    "title": "Basic Flow",
    "description": "Learn about basic flow in fp-ts flow",
    "category": "Flow",
    "fileName": "01-basic-flow.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst toString = (n: number): string => `Result: ${n}`\n\n// @ts-ignore\nconst processNumber = flow(\n  //TODO:\n  //Use flow to create a reusable function that:\n  //1. doubles a number\n  //2. adds 10\n  //3. converts to string\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst toString = (n: number): string => `Result: ${n}`\n\nexport const processNumber = flow(\n  double,\n  addTen,\n  toString\n)",
    "testCode": "describe('processNumber', () => {\n  it('creates reusable function: (5 * 2) + 10 = \"Result: 20\"', () => {\n    const result = processNumber(5)\n    expect(result).toEqual('Result: 20')\n  })\n\n  it('creates reusable function: (3 * 2) + 10 = \"Result: 16\"', () => {\n    const result = processNumber(3)\n    expect(result).toEqual('Result: 16')\n  })\n\n  it('can be called multiple times', () => {\n    expect(processNumber(0)).toEqual('Result: 10')\n    expect(processNumber(10)).toEqual('Result: 30')\n  })\n})"
  },
  {
    "id": "flow-02",
    "title": "With Option",
    "description": "Learn about with option in fp-ts flow",
    "category": "Flow",
    "fileName": "02-with-option.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\n// @ts-ignore\nconst getUserEmailById = flow(\n  //TODO:\n  //Use flow to create a reusable function that:\n  //1. Takes an id (number)\n  //2. Finds the user (returns User | undefined)\n  //3. Converts to Option\n  //4. Maps to extract email\n  //Returns O.Option<string>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\nexport const getUserEmailById = flow(\n  (id: number) => users.find(u => u.id === id),\n  O.fromNullable,\n  O.map(user => user.email)\n)",
    "testCode": "describe('getUserEmailById', () => {\n  it('returns Some with email when user found', () => {\n    const result = getUserEmailById(1)\n    expect(result).toEqual({ _tag: 'Some', value: 'alice@example.com' })\n  })\n\n  it('returns None when user not found', () => {\n    const result = getUserEmailById(99)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('is reusable', () => {\n    expect(getUserEmailById(2)).toEqual({ _tag: 'Some', value: 'bob@example.com' })\n    expect(getUserEmailById(1)).toEqual({ _tag: 'Some', value: 'alice@example.com' })\n  })\n})"
  },
  {
    "id": "flow-03",
    "title": "Composing Flows",
    "description": "Learn about composing flows in fp-ts flow",
    "category": "Flow",
    "fileName": "03-composing-flows.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst trim = (s: string): string => s.trim()\nconst toLowerCase = (s: string): string => s.toLowerCase()\nconst splitWords = (s: string): string[] => s.split(' ')\nconst countWords = (words: string[]): number => words.length\n\n// @ts-ignore\nconst normalizeText = flow(\n  //TODO: Create a flow that trims and converts to lowercase\n)\n\n// @ts-ignore\nconst countWordsInText = flow(\n  //TODO: Create a flow that normalizes text, splits into words, and counts them\n  //Hint: You can compose flows together!\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst trim = (s: string): string => s.trim()\nconst toLowerCase = (s: string): string => s.toLowerCase()\nconst splitWords = (s: string): string[] => s.split(' ')\nconst countWords = (words: string[]): number => words.length\n\nexport const normalizeText = flow(\n  trim,\n  toLowerCase\n)\n\nexport const countWordsInText = flow(\n  normalizeText,\n  splitWords,\n  countWords\n)",
    "testCode": "describe('text processing flows', () => {\n  it('normalizes text', () => {\n    const result = normalizeText('  Hello WORLD  ')\n    expect(result).toEqual('hello world')\n  })\n\n  it('counts words in text', () => {\n    const result = countWordsInText('  Hello WORLD  ')\n    expect(result).toEqual(2)\n  })\n\n  it('counts words in longer text', () => {\n    const result = countWordsInText('  The Quick Brown FOX  ')\n    expect(result).toEqual(4)\n  })\n\n  it('handles single word', () => {\n    const result = countWordsInText('  Hello  ')\n    expect(result).toEqual(1)\n  })\n})"
  },
  {
    "id": "flow-04",
    "title": "With Either",
    "description": "Learn about with either in fp-ts flow",
    "category": "Flow",
    "fileName": "04-with-either.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ntype ValidationError = 'Empty string' | 'Too short' | 'Invalid format'\n\nconst validateNotEmpty = (s: string): E.Either<ValidationError, string> =>\n  s.length > 0 ? E.right(s) : E.left('Empty string')\n\nconst validateMinLength = (min: number) => (s: string): E.Either<ValidationError, string> =>\n  s.length >= min ? E.right(s) : E.left('Too short')\n\nconst validateEmail = (s: string): E.Either<ValidationError, string> =>\n  s.includes('@') ? E.right(s) : E.left('Invalid format')\n\n// @ts-ignore\nconst validateEmailAddress = flow(\n  //TODO:\n  //Use flow to create an email validation function that:\n  //1. Validates not empty\n  //2. Chains to validate min length of 5\n  //3. Chains to validate email format\n  //Return E.Either<ValidationError, string>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ntype ValidationError = 'Empty string' | 'Too short' | 'Invalid format'\n\nconst validateNotEmpty = (s: string): E.Either<ValidationError, string> =>\n  s.length > 0 ? E.right(s) : E.left('Empty string')\n\nconst validateMinLength = (min: number) => (s: string): E.Either<ValidationError, string> =>\n  s.length >= min ? E.right(s) : E.left('Too short')\n\nconst validateEmail = (s: string): E.Either<ValidationError, string> =>\n  s.includes('@') ? E.right(s) : E.left('Invalid format')\n\nexport const validateEmailAddress = flow(\n  validateNotEmpty,\n  E.chain(validateMinLength(5)),\n  E.chain(validateEmail)\n)",
    "testCode": "describe('validateEmailAddress', () => {\n  it('accepts valid email', () => {\n    const result = validateEmailAddress('test@example.com')\n    expect(result).toEqual({ _tag: 'Right', right: 'test@example.com' })\n  })\n\n  it('rejects empty string', () => {\n    const result = validateEmailAddress('')\n    expect(result).toEqual({ _tag: 'Left', left: 'Empty string' })\n  })\n\n  it('rejects too short', () => {\n    const result = validateEmailAddress('a@b')\n    expect(result).toEqual({ _tag: 'Left', left: 'Too short' })\n  })\n\n  it('rejects invalid format', () => {\n    const result = validateEmailAddress('notanemail')\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid format' })\n  })\n})"
  },
  {
    "id": "flow-05",
    "title": "Practical Example",
    "description": "Learn about practical example in fp-ts flow",
    "category": "Flow",
    "fileName": "05-practical-example.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface RawUserData {\n  email: string\n  age: string\n  name: string\n}\n\ninterface User {\n  email: string\n  age: number\n  name: string\n}\n\ntype ParseError = 'Invalid email' | 'Invalid age' | 'Name too short'\n\nconst validateEmail = (data: RawUserData): E.Either<ParseError, RawUserData> =>\n  data.email.includes('@') ? E.right(data) : E.left('Invalid email')\n\nconst parseAge = (data: RawUserData): E.Either<ParseError, { email: string; age: number; name: string }> => {\n  const age = parseInt(data.age, 10)\n  return isNaN(age) ? E.left('Invalid age') : E.right({ ...data, age })\n}\n\nconst validateName = (data: { email: string; age: number; name: string }): E.Either<ParseError, User> =>\n  data.name.length >= 2 ? E.right(data) : E.left('Name too short')\n\n// @ts-ignore\nconst parseUser = flow(\n  //TODO:\n  //Create a flow that validates and parses raw user data:\n  //1. Validate email\n  //2. Chain to parse age\n  //3. Chain to validate name\n  //Returns E.Either<ParseError, User>\n  //Import flow from 'fp-ts/function'\n)",
    "solutionCode": "import { flow } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface RawUserData {\n  email: string\n  age: string\n  name: string\n}\n\ninterface User {\n  email: string\n  age: number\n  name: string\n}\n\ntype ParseError = 'Invalid email' | 'Invalid age' | 'Name too short'\n\nconst validateEmail = (data: RawUserData): E.Either<ParseError, RawUserData> =>\n  data.email.includes('@') ? E.right(data) : E.left('Invalid email')\n\nconst parseAge = (data: RawUserData): E.Either<ParseError, { email: string; age: number; name: string }> => {\n  const age = parseInt(data.age, 10)\n  return isNaN(age) ? E.left('Invalid age') : E.right({ ...data, age })\n}\n\nconst validateName = (data: { email: string; age: number; name: string }): E.Either<ParseError, User> =>\n  data.name.length >= 2 ? E.right(data) : E.left('Name too short')\n\nexport const parseUser = flow(\n  validateEmail,\n  E.chain(parseAge),\n  E.chain(validateName)\n)",
    "testCode": "describe('parseUser', () => {\n  it('successfully parses valid user data', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: '25',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({\n      _tag: 'Right',\n      right: { email: 'alice@example.com', age: 25, name: 'Alice' }\n    })\n  })\n\n  it('rejects invalid email', () => {\n    const rawData: RawUserData = {\n      email: 'notanemail',\n      age: '25',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid email' })\n  })\n\n  it('rejects invalid age', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: 'not a number',\n      name: 'Alice'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid age' })\n  })\n\n  it('rejects too short name', () => {\n    const rawData: RawUserData = {\n      email: 'alice@example.com',\n      age: '25',\n      name: 'A'\n    }\n    const result = parseUser(rawData)\n    expect(result).toEqual({ _tag: 'Left', left: 'Name too short' })\n  })\n})"
  },
  {
    "id": "option-01",
    "title": "Some And None",
    "description": "Learn about some and none in fp-ts option",
    "category": "Option",
    "fileName": "01-some-and-none.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\n// @ts-ignore\nconst getUserById = (users: User[], id: number): O.Option<User> => {\n  //TODO:\n  //Use the find method to search for the user in the users array that has the matching id.\n  //If the find method returns a user, return an option with the user wrapped in some.\n  //If the find method doesn't return a user, return an option with O.none.\n}",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n}\n\nexport const getUserById = (users: User[], id: number): O.Option<User> => {\n  const user = users.find(u => u.id === id)\n  return user ? O.some(user) : O.none\n}",
    "testCode": "describe('getUserById', () => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' },\n  ]\n\n  it('returns an option with user if it exists', () => {\n    const user = getUserById(users, 2)\n    expect(user).toEqual({ _tag: 'Some', value: { id: 2, name: 'Bob' } })\n  })\n\n  it('returns O.none if user does not exist', () => {\n    const user = getUserById(users, 4)\n    expect(user).toEqual({ _tag: 'None' })\n  })\n})"
  },
  {
    "id": "option-02",
    "title": "Of",
    "description": "Learn about of in fp-ts option",
    "category": "Option",
    "fileName": "02-of.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  //@ts-ignore\n  (user: User): O.Option<User> => {\n    //Create an option from a user.\n    //If the user has the same age as the given age, return an option with the user wrapped in some.\n    //If the user does not have the same age as the given age, return an option with O.none.\n    //Use the of function from the option module.\n  }",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  (user: User): O.Option<User> => {\n    return user.age === age ? O.of(user) : O.none\n  }",
    "testCode": "describe('createUserOptionFromAge', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30 }\n\n  it('returns some if user has same age as given age', () => {\n    const result = createUserOptionFromAge(30)(user2)\n    expect(result).toEqual(O.some(user2))\n  })\n\n  it('returns O.none if user does not have same age as given age', () => {\n    const result = createUserOptionFromAge(20)(user1)\n    expect(result).toEqual(O.none)\n  })\n})\n"
  },
  {
    "id": "option-03",
    "title": "From Predicate",
    "description": "Learn about from predicate in fp-ts option",
    "category": "Option",
    "fileName": "03-from-predicate.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  //@ts-ignore\n  (user: User): O.Option<User> => {\n    //Create a function that returns an option from a user.\n    //If the user has the same age as the given age, return an option with the user wrapped in some.\n    //If the user does not have the same age as the given age, return an option with O.none.\n    //Use the fromPredicate function from the option module.\n  }",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst createUserOptionFromAge =\n  (age: number) =>\n  (user: User): O.Option<User> => {\n    const isUserAge = (u: User) => u.age === age\n    return pipe(user, O.fromPredicate(isUserAge))\n  }",
    "testCode": "describe('createUserOptionFromAge', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30 }\n\n  it('returns some if user has same age as given age', () => {\n    const result = createUserOptionFromAge(30)(user2)\n    expect(result).toEqual(O.some(user2))\n  })\n\n  it('returns O.none if user does not have same age as given age', () => {\n    const result = createUserOptionFromAge(20)(user1)\n    expect(result).toEqual(O.none)\n  })\n})"
  },
  {
    "id": "option-04",
    "title": "Fold",
    "description": "Learn about fold in fp-ts option",
    "category": "Option",
    "fileName": "04-fold.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\n// @ts-ignore\nconst getUserEmail = (user: O.Option<User>): string => {\n  // Use the fold method on the Option object to handle both the some and O.none cases.\n  //In the some case, extract the email property from the User object and return it.\n  //In the O.none case, return a default message.\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst getUserEmail = (user: O.Option<User>): string =>\n  pipe(\n    user,\n    O.fold(\n      () => 'User email not available',\n      (user: User) => user.email\n    )\n  )",
    "testCode": "describe('getUserEmail', () => {\n  const user1: O.Option<User> = O.some({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n  })\n  const user2: O.Option<User> = O.none\n\n  it('returns user email if available', () => {\n    const result = getUserEmail(user1)\n    expect(result).toEqual('alice@example.com')\n  })\n\n  it('returns default message if user email is not available', () => {\n    const result = getUserEmail(user2)\n    expect(result).toEqual('User email not available')\n  })\n})"
  },
  {
    "id": "option-05",
    "title": "From Nullable",
    "description": "Learn about from nullable in fp-ts option",
    "category": "Option",
    "fileName": "05-from-nullable.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n  address?: string | null\n}\n\n//@ts-ignore\nconst getUserAddress = (user: User): O.Option<string> => {\n  //Create an Option from a nullable value using O.fromNullable()\n}",
    "solutionCode": "import * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n  address?: string | null\n}\n\nconst getUserAddress = (user: User): O.Option<string> => {\n  return O.fromNullable(user.address)\n}",
    "testCode": "describe('getUserAddress', () => {\n  const user1: User = { id: 1, name: 'Alice', age: 25 }\n  const user2: User = { id: 2, name: 'Bob', age: 30, address: '123 Main St' }\n  const user3: User = { id: 3, name: 'Charlie', age: 35, address: null }\n\n  it('returns O.none if user has no address', () => {\n    const result = getUserAddress(user1)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns some with the address if user has an address', () => {\n    const result = getUserAddress(user2)\n    expect(result).toEqual({ _tag: 'Some', value: '123 Main St' })\n  })\n\n  it('returns O.none if user has a null address', () => {\n    const result = getUserAddress(user3)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})\n"
  },
  {
    "id": "option-06",
    "title": "To Nullable",
    "description": "Learn about to nullable in fp-ts option",
    "category": "Option",
    "fileName": "06-to-nullable.exercise.ts",
    "difficulty": "intermediate",
    "order": 6,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddress = (addressOption: O.Option<string>): string | null => {\n  //Return null if addressOption is O.none and the address string if addressOption is some\n  //Use O.toNullable()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\nconst getAddress = (addressOption: O.Option<string>): string | null => {\n  return O.toNullable(addressOption)\n}",
    "testCode": "describe('getAddressString', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns null if address option is O.none', () => {\n    const result = getAddress(addressOption1)\n    expect(result).toBeNull()\n  })\n\n  it('returns the address string in the correct format if address option is some', () => {\n    const result = getAddress(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})"
  },
  {
    "id": "option-07",
    "title": "To Undefined",
    "description": "Learn about to undefined in fp-ts option",
    "category": "Option",
    "fileName": "07-to-undefined.exercise.ts",
    "difficulty": "advanced",
    "order": 7,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddress = (addressOption: O.Option<string>): string | undefined => {\n  //Return null if addressOption is O.none and the address string if addressOption is some\n  //Use O.toUndefined()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\nconst getAddress = (addressOption: O.Option<string>): string | undefined => {\n  return O.toUndefined(addressOption)\n}",
    "testCode": "describe('getAddress', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns undefined if address option is O.none', () => {\n    const result = getAddress(addressOption1)\n    expect(result).toBeUndefined()\n  })\n\n  it('returns the address string in the correct format if address option is some', () => {\n    const result = getAddress(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})\n"
  },
  {
    "id": "option-08",
    "title": "Get Or Else",
    "description": "Learn about get or else in fp-ts option",
    "category": "Option",
    "fileName": "08-get-or-else.exercise.ts",
    "difficulty": "advanced",
    "order": 8,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getAddressString = (addressOption: O.Option<string>): string => {\n  //Return 'No address provided' if addressOption is O.none and the address string if addressOption is some\n  //Use O.getOrElse()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst getAddressString = (addressOption: O.Option<string>): string => {\n  return pipe(\n    addressOption,\n    O.getOrElse(() => 'No address provided')\n  )\n}",
    "testCode": "describe('getAddressString', () => {\n  const addressOption1: O.Option<string> = O.none\n  const addressOption2: O.Option<string> = O.some('123 Main St')\n\n  it('returns default string when address option is O.none', () => {\n    const result = getAddressString(addressOption1)\n    expect(result).toEqual('No address provided')\n  })\n\n  it('returns the address string in the correct format when address option is some', () => {\n    const result = getAddressString(addressOption2)\n    expect(result).toEqual('123 Main St')\n  })\n})\n"
  },
  {
    "id": "option-09",
    "title": "Filter",
    "description": "Learn about filter in fp-ts option",
    "category": "Option",
    "fileName": "09-filter.exercise.ts",
    "difficulty": "advanced",
    "order": 9,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\n//@ts-ignore\nconst getValidUserAddress = (address: O.Option<string>): O.Option<string> => {\n  //Return O.none if address is O.none and the address string if address is some\n  //Use O.filter()\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst getValidUserAddress = (address: O.Option<string>): O.Option<string> =>\n  pipe(\n    address,\n    O.filter(address => address.length >= 5)\n  )",
    "testCode": "describe('getValidUserAddress', () => {\n  it('returns O.none if user has no address', () => {\n    const result = getValidUserAddress(O.none)\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns O.none if user has an address that is too short', () => {\n    const result = getValidUserAddress(O.of('456'))\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns the valid address if user has an address that is long enough', () => {\n    const result = getValidUserAddress(O.of('123 Main St'))\n    expect(result).toEqual(O.some('123 Main St'))\n  })\n})\n"
  },
  {
    "id": "option-10",
    "title": "From Either",
    "description": "Learn about from either in fp-ts option",
    "category": "Option",
    "fileName": "10-from-either.exercise.ts",
    "difficulty": "advanced",
    "order": 10,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst getUserById = (id: number): E.Either<string, User> => {\n  if (id < 1) {\n    return E.left('Invalid user ID')\n  }\n  return E.right({ id, name: `User ${id}`, age: id * 10 })\n}\n\n//@ts-ignore\nconst getUserOptionById = (id: number): O.Option<User> => {\n  //create a function that takes an id and returns an option of user using getUserById\n}",
    "solutionCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst getUserById = (id: number): E.Either<string, User> => {\n  if (id < 1) {\n    return E.left('Invalid user ID')\n  }\n  return E.right({ id, name: `User ${id}`, age: id * 10 })\n}\n\nconst getUserOptionById = (id: number): O.Option<User> =>\n  O.fromEither(getUserById(id))",
    "testCode": "describe('getUserOptionById', () => {\n  it('returns O.none if user ID is less than 1', () => {\n    const result = getUserOptionById(0)\n    expect(result).toEqual(O.none)\n  })\n\n  it('returns a some object with the user if user ID is valid', () => {\n    const result = getUserOptionById(2)\n    expect(result).toEqual(O.some({ id: 2, name: 'User 2', age: 20 }))\n  })\n})\n"
  },
  {
    "id": "pipe-01",
    "title": "Basic Pipe",
    "description": "Learn about basic pipe in fp-ts pipe",
    "category": "Pipe",
    "fileName": "01-basic-pipe.exercise.ts",
    "difficulty": "beginner",
    "order": 1,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst square = (n: number): number => n * n\n\n// @ts-ignore\nconst transform = (n: number): number => {\n  //TODO:\n  //Use pipe to compose the following operations in order:\n  //1. double the number\n  //2. add 10\n  //3. square the result\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\nconst double = (n: number): number => n * 2\nconst addTen = (n: number): number => n + 10\nconst square = (n: number): number => n * n\n\nexport const transform = (n: number): number =>\n  pipe(\n    n,\n    double,\n    addTen,\n    square\n  )",
    "testCode": "describe('transform', () => {\n  it('applies transformations in correct order: (5 * 2 + 10)^2 = 400', () => {\n    const result = transform(5)\n    expect(result).toEqual(400)\n  })\n\n  it('applies transformations in correct order: (3 * 2 + 10)^2 = 256', () => {\n    const result = transform(3)\n    expect(result).toEqual(256)\n  })\n\n  it('applies transformations in correct order: (0 * 2 + 10)^2 = 100', () => {\n    const result = transform(0)\n    expect(result).toEqual(100)\n  })\n})"
  },
  {
    "id": "pipe-02",
    "title": "With Option",
    "description": "Learn about with option in fp-ts pipe",
    "category": "Pipe",
    "fileName": "02-with-option.exercise.ts",
    "difficulty": "beginner",
    "order": 2,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 30 },\n  { id: 3, name: 'Charlie', age: 35 },\n]\n\n// @ts-ignore\nconst getUserNameById = (id: number): O.Option<string> => {\n  //TODO:\n  //Use pipe to:\n  //1. Find the user by id (returns User | undefined)\n  //2. Convert to Option using O.fromNullable\n  //3. Map to extract the user's name\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', age: 25 },\n  { id: 2, name: 'Bob', age: 30 },\n  { id: 3, name: 'Charlie', age: 35 },\n]\n\nexport const getUserNameById = (id: number): O.Option<string> =>\n  pipe(\n    users.find(u => u.id === id),\n    O.fromNullable,\n    O.map(user => user.name)\n  )",
    "testCode": "describe('getUserNameById', () => {\n  it('returns Some with user name when found', () => {\n    const result = getUserNameById(2)\n    expect(result).toEqual({ _tag: 'Some', value: 'Bob' })\n  })\n\n  it('returns None when user not found', () => {\n    const result = getUserNameById(99)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})"
  },
  {
    "id": "pipe-03",
    "title": "With Either",
    "description": "Learn about with either in fp-ts pipe",
    "category": "Pipe",
    "fileName": "03-with-either.exercise.ts",
    "difficulty": "beginner",
    "order": 3,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as E from 'fp-ts/Either'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\ntype UserError = 'Invalid ID' | 'User not found'\n\n// @ts-ignore\nconst getUserEmail = (id: number): E.Either<UserError, string> => {\n  //TODO:\n  //Use pipe to:\n  //1. Validate that id > 0 using E.fromPredicate (error: 'Invalid ID')\n  //2. Chain to find the user (error: 'User not found' if not found)\n  //3. Map to extract the email\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport { describe, it, expect } from 'vitest'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' },\n]\n\ntype UserError = 'Invalid ID' | 'User not found'\n\nexport const getUserEmail = (id: number): E.Either<UserError, string> =>\n  pipe(\n    id,\n    E.fromPredicate(\n      (id) => id > 0,\n      () => 'Invalid ID' as UserError\n    ),\n    E.chain((id) => {\n      const user = users.find(u => u.id === id)\n      return user ? E.right(user) : E.left('User not found' as UserError)\n    }),\n    E.map(user => user.email)\n  )",
    "testCode": "describe('getUserEmail', () => {\n  it('returns Right with email when user found', () => {\n    const result = getUserEmail(1)\n    expect(result).toEqual({ _tag: 'Right', right: 'alice@example.com' })\n  })\n\n  it('returns Left for invalid ID', () => {\n    const result = getUserEmail(0)\n    expect(result).toEqual({ _tag: 'Left', left: 'Invalid ID' })\n  })\n\n  it('returns Left when user not found', () => {\n    const result = getUserEmail(99)\n    expect(result).toEqual({ _tag: 'Left', left: 'User not found' })\n  })\n})"
  },
  {
    "id": "pipe-04",
    "title": "Array Operations",
    "description": "Learn about array operations in fp-ts pipe",
    "category": "Pipe",
    "fileName": "04-array-operations.exercise.ts",
    "difficulty": "intermediate",
    "order": 4,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  inStock: boolean\n}\n\nconst products: Product[] = [\n  { id: 1, name: 'Laptop', price: 1000, inStock: true },\n  { id: 2, name: 'Mouse', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', price: 75, inStock: true },\n  { id: 4, name: 'Monitor', price: 300, inStock: true },\n  { id: 5, name: 'Webcam', price: 50, inStock: false },\n]\n\n// @ts-ignore\nconst getAffordableInStockProductNames = (maxPrice: number): string[] => {\n  //TODO:\n  //Use pipe with array methods to:\n  //1. Filter products that are inStock\n  //2. Filter products where price <= maxPrice\n  //3. Map to get product names\n  //4. Sort alphabetically\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport { describe, it, expect } from 'vitest'\n\ninterface Product {\n  id: number\n  name: string\n  price: number\n  inStock: boolean\n}\n\nconst products: Product[] = [\n  { id: 1, name: 'Laptop', price: 1000, inStock: true },\n  { id: 2, name: 'Mouse', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', price: 75, inStock: true },\n  { id: 4, name: 'Monitor', price: 300, inStock: true },\n  { id: 5, name: 'Webcam', price: 50, inStock: false },\n]\n\nexport const getAffordableInStockProductNames = (maxPrice: number): string[] =>\n  pipe(\n    products,\n    (ps) => ps.filter(p => p.inStock),\n    (ps) => ps.filter(p => p.price <= maxPrice),\n    (ps) => ps.map(p => p.name),\n    (names) => names.sort()\n  )",
    "testCode": "describe('getAffordableInStockProductNames', () => {\n  it('returns products under 100', () => {\n    const result = getAffordableInStockProductNames(100)\n    expect(result).toEqual(['Keyboard'])\n  })\n\n  it('returns products under 500', () => {\n    const result = getAffordableInStockProductNames(500)\n    expect(result).toEqual(['Keyboard', 'Monitor'])\n  })\n\n  it('returns empty array when no products match', () => {\n    const result = getAffordableInStockProductNames(10)\n    expect(result).toEqual([])\n  })\n})"
  },
  {
    "id": "pipe-05",
    "title": "Real World",
    "description": "Learn about real world in fp-ts pipe",
    "category": "Pipe",
    "fileName": "05-real-world.exercise.ts",
    "difficulty": "intermediate",
    "order": 5,
    "exerciseCode": "import { describe, it, expect } from 'vitest'\nimport * as O from 'fp-ts/Option'\n\ninterface ApiResponse {\n  data?: {\n    user?: {\n      profile?: {\n        name: string\n        age: number\n      }\n    }\n  }\n}\n\n// @ts-ignore\nconst extractUserAge = (response: ApiResponse): O.Option<number> => {\n  //TODO:\n  //Use pipe to safely extract the user's age from the nested API response\n  //1. Start with response.data\n  //2. Use O.fromNullable to handle undefined\n  //3. Chain through user, profile, and age\n  //Return None if any part of the chain is undefined\n  //Import pipe from 'fp-ts/function'\n}",
    "solutionCode": "import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport { describe, it, expect } from 'vitest'\n\ninterface ApiResponse {\n  data?: {\n    user?: {\n      profile?: {\n        name: string\n        age: number\n      }\n    }\n  }\n}\n\nexport const extractUserAge = (response: ApiResponse): O.Option<number> =>\n  pipe(\n    response.data,\n    O.fromNullable,\n    O.chain(data => O.fromNullable(data.user)),\n    O.chain(user => O.fromNullable(user.profile)),\n    O.map(profile => profile.age)\n  )",
    "testCode": "describe('extractUserAge', () => {\n  it('extracts age from complete response', () => {\n    const response: ApiResponse = {\n      data: {\n        user: {\n          profile: {\n            name: 'Alice',\n            age: 25\n          }\n        }\n      }\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'Some', value: 25 })\n  })\n\n  it('returns None when data is missing', () => {\n    const response: ApiResponse = {}\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns None when user is missing', () => {\n    const response: ApiResponse = {\n      data: {}\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n\n  it('returns None when profile is missing', () => {\n    const response: ApiResponse = {\n      data: {\n        user: {}\n      }\n    }\n    const result = extractUserAge(response)\n    expect(result).toEqual({ _tag: 'None' })\n  })\n})"
  }
]
